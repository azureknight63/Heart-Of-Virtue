"""
Combat moves to be used within combat module. Moves are objects generated by player/AI action during combat.
"""
from termcolor import colored
import random

class Move: #master class for all moves
    def __init__(self, name, description, xp_gain, heat_gain, current_stage, beats_left,
                 stage_announce, fatigue_cost, target, user, stage_beat, targeted):
        self.name = name
        self.description = description
        self.xp_gain = xp_gain
        self.heat_gain = heat_gain
        self.current_stage = current_stage
        self.stage_beat = stage_beat
        self.beats_left = beats_left
        self.stage_announce = stage_announce
        self.fatigue_cost = fatigue_cost
        self.target = target # can be the same as the user in abilities with no targets
        self.user = user
        self.targeted = targeted # Is the move targeted at something?

    def process_stage(self,player):
        if player.current_move == self:
            if self.current_stage == 0:
                self.prep(player)
            elif self.current_stage == 1:
                self.execute(player)
            elif self.current_stage == 2:
                self.recoil(player)
            elif self.current_stage == 3:
                self.cooldown(player)  # the cooldown stage will typically never be rewritten, so this will usually just pass

    def cast(self, player): # this is what happens when the ability is first chosen by the player
        self.current_stage = 0 # initialize prep stage
        self.process_stage(player) # if there is anything that happens when a move is prepped, do that now
        self.beats_left = self.stage_beat[0]

    def advance(self, player):
        if player.current_move == self or self.current_stage == 3: # only advance the move if it's the player's current move or if it's in cooldown
            if self.beats_left > 0:
                self.beats_left -= 1
            else:
                while self.beats_left == 0: # this loop will advance stages until the current stage has a beat count, effectively skipping unused stages
                    self.process_stage(player)
                    self.current_stage += 1  # switch to next stage
                    if self.current_stage == 3: # when the move enters cooldown, detach it from the player so he can do something else.
                        player.current_move = None
                    if self.current_stage > 3: # if the move is coming out of cooldown, switch back to the prep stage and break the while loop
                        self.current_stage = 0
                        self.beats_left = self.stage_beat[self.current_stage]
                        break
                    self.beats_left = self.stage_beat[self.current_stage] # set beats remaining for current stage

    def prep(self, player): #what happens during these stages. Each move will overwrite prep/execute/recoil/cooldown depending on whether something is supposed to happen at that stage
        # print("######{}: I'm in the prep stage now".format(self.name)) #debug message
        pass

    def execute(self, player):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        pass

    def recoil(self, player):
        # print("######{}: I'm in the recoil stage now".format(self.name)) #debug message
        pass

    def cooldown(self, player):
        # print("######{}: I'm in the cooldown stage now".format(self.name)) #debug message
        pass

class Attack(Move): #basic attack function, always uses equipped weapon
    def __init__(self, player):
        description = "Strike at your enemy with your equipped weapon."
        power = player.eq_weapon.damage + \
                    (player.strength * player.eq_weapon.str_mod) + \
                    (player.finesse * player.eq_weapon.fin_mod)
        prep = 1
        execute = 1
        recoil = 1 + player.eq_weapon.weight
        cooldown = 5 - (player.speed/10)
        if cooldown < 0:
            cooldown = 0
        weapon = player.eq_weapon.name
        fatigue_cost = 100 - (7 * player.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        super().__init__(name="Attack", description=description, xp_gain=1, heat_gain= 0.1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True,
                         stage_announce=["You wind up for a strike...",
                                         colored("You strike with your " + weapon + "!", "green"),
                                         "You brace yourself as your weapon recoils.",
                                         "You are ready to attack again."], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player)
        self.power = power

    def prep(self, player):
        # print("######{}: I'm in the prep stage now".format(self.name)) #debug message
        if self.beats_left == self.stage_beat[0]:
            print(self.stage_announce[0])

    def execute(self, player):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        print(self.stage_announce[1])
        hit_chance = 95 - self.target.finesse + player.finesse
        roll = random.randint(0, 100)
        damage = ((self.power - self.target.armor) * player.heat) * random.uniform(0.8, 1.2)
        damage = int(damage)
        if hit_chance >= roll: #a hit!
            print(colored(self.target.name, "magenta") + colored(" was struck for ", "yellow") +
                  colored(damage, "red") + colored(" damage!", "yellow"))
            self.target.hp -= damage
            # print("######{}'s HP is {}".format(self.target.name, self.target.hp)) #debug msg
            player.change_heat(1.25)
        else:
            print(colored("Just missed!", "white"))
            player.change_heat(0.75)
        player.fatigue -= self.fatigue_cost

class Rest(Move): #basic attack function, always uses equipped weapon
    def __init__(self, player):
        description = "Rest for a moment to restore fatigue."
        prep = 0
        execute = 3
        recoil = 0
        cooldown = 0
        fatigue_cost = -1 * (40 + player.endurance)
        super().__init__(name="Rest", description=description, xp_gain=0, heat_gain=0.1, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["You relax your muscles for a moment.",
                                         colored("You are resting.", "green"),
                                         "You brace yourself as your weapon recoils.",
                                         "You are ready to attack again."], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)