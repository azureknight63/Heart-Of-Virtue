__author__ = 'Alex Egbert'

import functions
import json, os, inspect
from pathlib import Path
from typing import Final

RESOURCES_DIR: Final = Path(__file__).parent / 'resources'


def tile_exists(map_to_check, x, y):
    """Returns the tile at the given coordinates or None if there is no tile.
    :param map_to_check: the dictionary object containing the tile
    :param x: the x-coordinate in the worldspace
    :param y: the y-coordinate in the worldspace
    :return: the tile at the given coordinates or None if there is no tile
    """
    return map_to_check.get((x, y))


class Universe:  # "globals" for the game state can be stored here, as well as all the maps
    def __init__(self):
        self.game_tick = 0
        self.maps = []
        self.starting_position = (0, 0)
        self.starting_map_default = None
        self.story = {  # global switches and variables.
            # Putting them in a dict will make it easier to change on the fly while debugging
            "gorran_first": "0"
        }
        self.locked_chests = []

    def build(self, player):  # builds all the maps as they are, then loads them into self.maps
        if player.saveuniv is not None and player.savestat is not None:
            self.maps = player.saveuniv
        else:  # new game
            # First load any JSON maps generated by map_generator (preferred modern format)
            self._load_all_json_maps(player)
            # Then (legacy) load txt maps if still present / desired
            legacy_map_list = ["testing", "start_area", "verdette_caverns", "grondia"]
            for location in legacy_map_list:
                # Only load legacy if a json variant wasn't already loaded (avoid duplicates)
                if not any(m.get('name') == location for m in self.maps):
                    txt_path = RESOURCES_DIR / f"{location}.txt"
                    if txt_path.exists():
                        self.load_tiles(player, location)
            # determine starting map
            for location in self.maps:
                if "start" in location['name'] and self.starting_map_default is None:
                    self.starting_map_default = location

    # ---------------- JSON MAP SUPPORT -----------------
    def _json_maps_root_candidates(self):
        """Return candidate directories that may contain json map files."""
        candidates = []
        # primary resources/maps under src/resources
        maps_dir = RESOURCES_DIR / 'maps'
        candidates.append(maps_dir)
        # also accept utils/src/resources/maps (where the editor saves by default)
        utils_variant = Path(__file__).parent.parent / 'utils' / 'src' / 'resources' / 'maps'
        candidates.append(utils_variant)
        return [c for c in candidates if c.exists()]

    def _load_all_json_maps(self, player):
        loaded = 0
        for root in self._json_maps_root_candidates():
            for jf in sorted(root.glob('*.json')):
                try:
                    self._load_single_json_map(player, jf)
                    loaded += 1
                except Exception:
                    # Silent fail - keep game running; optionally could log
                    pass
        return loaded

    def _deserialize_saved_instance(self, payload):
        """Deserialize an instance saved by map_generator (class+module+props). Returns object or None."""
        if not isinstance(payload, dict) or '__class__' not in payload:
            return None
        cls_name = payload.get('__class__')
        mod_name = payload.get('__module__')
        props = payload.get('props', {})
        try:
            module = __import__(mod_name, fromlist=[cls_name])
            cls = getattr(module, cls_name)
            # Try to supply only parameters accepted by __init__ (excluding self)
            try:
                sig = inspect.signature(cls.__init__)
                pnames = [p.name for p in sig.parameters.values() if p.name != 'self']
                init_kwargs = {k: v for k, v in props.items() if k in pnames}
                inst = cls(**init_kwargs)
            except Exception:
                inst = cls.__new__(cls)
                try:
                    cls.__init__(inst)  # type: ignore
                except Exception:
                    pass
            # Apply remaining props as attributes
            for k, v in props.items():
                try:
                    setattr(inst, k, v)
                except Exception:
                    pass
            return inst
        except Exception:
            return None

    def _load_single_json_map(self, player, json_path: Path):
        with open(json_path, 'r', encoding='utf-8') as f:
            raw = json.load(f)
        map_name = json_path.stem
        this_map: dict = {'name': map_name}
        # iterate coordinate keys
        for coord_str, tile_data in raw.items():
            try:
                x_str, y_str = coord_str.strip('()').split(',')
                x = int(x_str)
                y = int(y_str)
            except Exception:
                continue
            # determine tile class name from title; fallback to generic MapTile if not found
            title = tile_data.get('title') or tile_data.get('id') or f"tile_{x}_{y}"
            description = tile_data.get('description', '')
            try:
                tile_cls = functions.seek_class(title, 'tilesets')
            except Exception:
                from tiles import MapTile as tile_cls  # fallback
            tile_instance = tile_cls(self, this_map, x, y, description=description)
            # block exits & symbol
            if 'block_exit' in tile_data and isinstance(tile_data['block_exit'], list):
                tile_instance.block_exit = list(tile_data['block_exit'])
            if 'symbol' in tile_data and hasattr(tile_instance, 'symbol'):
                try:
                    tile_instance.symbol = tile_data['symbol']
                except Exception:
                    pass
            # events
            for ev_payload in tile_data.get('events', []):
                inst = self._deserialize_saved_instance(ev_payload)
                if inst:
                    try:
                        # attach minimal expected attributes if missing
                        if hasattr(inst, 'tile'):
                            inst.tile = tile_instance
                        tile_instance.events_here.append(inst)
                    except Exception:
                        pass
            # items
            for it_payload in tile_data.get('items', []):
                inst = self._deserialize_saved_instance(it_payload)
                if inst:
                    tile_instance.items_here.append(inst)
            # npcs
            for npc_payload in tile_data.get('npcs', []):
                inst = self._deserialize_saved_instance(npc_payload)
                if inst:
                    tile_instance.npcs_here.append(inst)
            # objects
            for obj_payload in tile_data.get('objects', []):
                inst = self._deserialize_saved_instance(obj_payload)
                if inst:
                    tile_instance.objects_here.append(inst)
            this_map[(x, y)] = tile_instance
            if title == 'StartingRoom':
                self.starting_position = (x, y)
        self.maps.append(this_map)

    def load_tiles(self, player, mapname):
        """Parses a file that describes the world space into the _world object"""
        this_map: dict = {'name': mapname}
        file_path = RESOURCES_DIR.joinpath(mapname + '.txt')
        with open(file_path, 'r') as f:
            rows = [line.rstrip('\n') for line in f]
        # x_max = len(rows[0].split('\t'))
        for y, row in enumerate(rows):
            cols = row.split('\t')
            for x, block_contents in enumerate(cols):
                if block_contents:
                    block_list = block_contents.split("|")
                    tile_name = block_list[0]
                    this_map[(x, y)] = functions.seek_class(tile_name, 'tilesets')(self, this_map, x, y)
                    if len(block_list) > 1:
                        for i, param in enumerate(block_list):
                            if i != 0:
                                if param[0] == '~':  # sets the given parameter for the tile object based on
                                                        # what's in the map editor
                                    parameter = param.split('=')
                                    if hasattr(tile_exists(this_map, x, y), parameter[0]):
                                        setattr(tile_exists(this_map, x, y), parameter[0], parameter[1])
                                elif param[0] == '$':  # spawns any declared NPCs
                                    param = param.replace('$', '')
                                    p_list = param.split('.')
                                    npc_type = p_list[0]
                                    amt = functions.randomize_amount(p_list[1])
                                    hidden = False
                                    hfactor = 0
                                    for item in p_list:
                                        hidden, hfactor = self.parse_hidden(item)
                                    if len(p_list) == 3:  # if the npc is declared hidden, set appropriate values
                                        hidden = True
                                        hfactor = int(p_list[2][1:])
                                    for ix in range(0, amt):
                                        tile_exists(this_map, x, y).spawn_npc(npc_type, hidden=hidden,
                                                                              hfactor=hfactor)
                                elif param[0] == '#':  # spawns any declared items
                                    param = param.replace('#', '')
                                    p_list = param.split('.')
                                    item_type = p_list[0]
                                    amt = functions.randomize_amount(p_list[1])
                                    hidden = False
                                    hfactor = 0
                                    for item in p_list:
                                        hidden, hfactor = self.parse_hidden(item)
                                    tile_exists(this_map, x, y).spawn_item(item_type, amt=amt, hidden=hidden,
                                                                           hfactor=hfactor)

                                elif param[0] == '!':  # spawns any declared events
                                    param = param.replace('!', '')
                                    event_type = param
                                    repeat = False
                                    params = []
                                    if '.' in param:
                                        p_list = param.split('.')
                                        event_type = p_list.pop(0)
                                        for setting in p_list:
                                            if setting == 'r':
                                                repeat = True
                                                p_list.remove(setting)
                                                continue
                                            params.append(setting)
                                    tile_exists(this_map, x, y).spawn_event(event_type,
                                                                            player,
                                                                            tile_exists(this_map, x, y),
                                                                            repeat,
                                                                            params)
                                elif param[0] == '@':  # spawns any declared objects
                                    param = param.replace('@', '')
                                    p_list = param.split('.')
                                    obj_type = p_list[0]
                                    amt = functions.randomize_amount(p_list[1])
                                    hidden = False
                                    hfactor = 0
                                    params = []
                                    if len(p_list) > 2:
                                        for setting in p_list:
                                            if setting != '':
                                                hidden, hfactor = self.parse_hidden(setting)
                                                if not hidden:
                                                    params.append(setting)
                                    p_list.remove(obj_type)
                                    for ix in range(0, amt):
                                        tile_exists(this_map, x, y).spawn_object(obj_type, player,
                                                                                 tile_exists(this_map, x, y),
                                                                                 params=params, hidden=hidden,
                                                                                 hfactor=hfactor)
                else:
                    tile_name = block_contents
                    this_map[(x, y)] = None if tile_name == '' else getattr(__import__('tiles'), tile_name)(self,
                                                                                                            this_map, x,
                                                                                                            y)
                if tile_name == 'StartingRoom':  # there can only be one of these in the game
                    self.starting_position = (x, y)

        self.maps.append(this_map)

    @staticmethod
    def parse_hidden(setting: str) -> tuple[bool, int]:
        hidden = False
        hfactor = 0

        if "h+" in setting:
            hidden = True
            hfactor = int(setting[2:])

        return hidden, hfactor
