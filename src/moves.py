"""
Combat moves to be used within combat module. Moves are objects generated by player/AI action during combat.
"""
from termcolor import colored, cprint
import random, time
import states, functions

class Move:  # master class for all moves
    def __init__(self, name, description, xp_gain, current_stage, beats_left,
                 stage_announce, target, user, stage_beat, targeted, mvrange=(0,9999), heat_gain=0, fatigue_cost=0,
                 instant=False):
        self.name = name
        self.description = description
        self.xp_gain = xp_gain
        self.heat_gain = heat_gain
        self.current_stage = current_stage
        self.stage_beat = stage_beat
        self.beats_left = beats_left
        self.stage_announce = stage_announce
        self.fatigue_cost = fatigue_cost
        self.target = target  # can be the same as the user in abilities with no targets
        self.user = user
        self.targeted = targeted  # Is the move targeted at something?
        self.interrupted = False  # When a move is interrupted, skip all remaining actions for that move, set the
        # move's cooldown
        self.initialized = False
        self.usercolor = "white"
        self.targetcolor = "white"
        self.mvrange = mvrange  # tuple containing the min and max ranges for the move
        self.instant = instant  # moves flagged as instant do not allow any beats to pass before completing all stages
        self.weight = 1  # only used by NPCs to determine the chance that move is selected for use

    def viable(self):
        '''Check arbitrary conditions to see if the move is available for use; return True or False'''
        viability = True
        return viability


    def process_stage(self, user):
        if user.current_move == self:
            if self.current_stage == 0:
                self.prep(user)
            elif self.current_stage == 1:
                self.execute(user)
            elif self.current_stage == 2:
                self.recoil(user)
            elif self.current_stage == 3:
                self.cooldown(user)  # the cooldown stage will typically never be rewritten,
                # so this will usually just pass

    def cast(self, user): # this is what happens when the ability is first chosen by the player
        self.current_stage = 0 # initialize prep stage
        if self.stage_announce[0] != "":
            print(self.stage_announce[0])  # Print the prep announce message for the move
        self.beats_left = self.stage_beat[0]

    def advance(self, user):
        self.evaluate()
        if user.current_move == self or self.current_stage == 3:  # only advance the move if it's the player's
            # current move or if it's in cooldown
            #print("###DEBUG: " + user.name + " " + self.name + " STAGE: " + str(self.current_stage) +
            #      " BEATS LEFT: " + str(self.beats_left))
            if self.beats_left > 0:
                self.beats_left -= 1
            else:
                while self.beats_left == 0:  # this loop will advance stages until the current stage has a beat count,
                    # effectively skipping unused stages; if the move is instant, pretend all beat counts are 0!
                    self.process_stage(user)
                    self.current_stage += 1  # switch to next stage
                    if self.current_stage == 3:  # when the move enters cooldown, detach it from the player so he can
                        # do something else.
                        user.current_move = None
                        self.initialized = False
                    if self.current_stage > 3: # if the move is coming out of cooldown, switch back to the prep stage
                        # and break the while loop
                        self.current_stage = 0
                        self.beats_left = self.stage_beat[self.current_stage]
                        break
                    self.beats_left = self.stage_beat[self.current_stage]  # set beats remaining for current stage

    def prep(self, user): #what happens during these stages. Each move will overwrite prep/execute/recoil/cooldown
        # depending on whether something is supposed to happen at that stage
        # print("######{}: I'm in the prep stage now".format(self.name)) #debug message
        pass

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        if self.stage_announce[1] != "":
            print(self.stage_announce[1])

    def recoil(self, user):
        # print("######{}: I'm in the recoil stage now".format(self.name)) #debug message
       if self.stage_announce[2] != "":
            print(self.stage_announce[2])

    def cooldown(self, user):
        # print("######{}: I'm in the cooldown stage now".format(self.name)) #debug message
        pass

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        pass

    def check_parry(self, target):
        parry = False
        for state in target.states:
            if state.name == "Parrying":
                parry = True
                break
        return parry

    def prep_colors(self):  # prepares usercolor, targetcolor for prints
        player = ""
        if self.user.name == "Jean":
            player = self.user
        else:
            if not self.user.friend:
                self.usercolor = "magenta"
            else:
                self.usercolor = "cyan"
        if self.target.name == "Jean":
            player = self.target
        else:
            if not self.target.friend:
                self.targetcolor = "magenta"
            else:
                self.targetcolor = "cyan"
        if self.user == player:
            self.usercolor = "green"
        if self.target == player:
            self.targetcolor = "green"

    def parry(self):
        print(colored(self.target.name, self.targetcolor) + colored(" parried the attack from ", "red") +
              colored(self.user.name, self.usercolor) + colored("!", "red"))
        self.stage_beat[2] += 10  # add stagger time to the user
        if self.target.name == "Jean":
            self.target.change_heat(1.4)
            self.target.combat_exp += 15
        if self.user.name == "Jean":
            self.user.change_heat(0.75)

    def hit(self, damage, glance):
        if glance:
            print(colored(self.user.name, self.usercolor) + colored(" just barely hit ", "yellow") +
                  colored(self.target.name, self.targetcolor) + colored(" for ", "yellow") +
                  colored(damage, "red") + colored(" damage!", "yellow"))
        else:
            print(colored(self.user.name, self.usercolor) + colored(" struck ", "yellow") +
                  colored(self.target.name, self.targetcolor) + colored(" for ", "yellow") +
                  colored(damage, "red") + colored(" damage!", "yellow"))
        self.target.hp -= damage
        # print("######{}'s HP is {}".format(self.target.name, self.target.hp)) #debug msg
        if self.target.name == "Jean":
            self.target.change_heat(
                1 - (damage / self.target.maxhp))  # reduce heat by the percentage of dmg done to maxhp
            self.target.combat_exp += 15
        if self.user.name == "Jean":
            self.user.change_heat(1.25)
            self.user.combat_exp += (damage/4)

    def miss(self):
        print(colored(self.user.name, self.usercolor) + "'s attack just missed!")
        if self.target.name == "Jean":
            for state in self.target.states:
                if state.name == "Dodging":
                    self.target.change_heat(1.25)
                    self.target.combat_exp += 10
                    break
            self.target.change_heat(1.1)
            self.target.combat_exp += 5
        if self.user.name == "Jean":
            self.user.change_heat(0.85)

### ANY MOVES ###

class Dodge(Move):
    def __init__(self, user):
        description = "Prepare to dodge incoming attacks."
        prep = 1
        execute = 1
        recoil = 5
        cooldown = 2
        fatigue_cost = 0
        super().__init__(name="Dodge", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=False,
                         stage_announce=["",
                                         "{} tenses in preparation to avoid attacks.".format(user.name),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=user, user=user)
        self.evaluate()

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        self.stage_beat = [1,1,5,2]
        self.fatigue_cost = 75 - ((2 * self.user.endurance) + (3 * self.user.speed))
        if self.fatigue_cost <= 10:
            self.fatigue_cost = 10

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        print(self.stage_announce[1])
        for state in self.user.states:  # remove any other instances of Dodging
            if isinstance(state, states.Dodging):
                self.user.states.remove(state)
        self.user.states.append(states.Dodging(user))
        self.user.fatigue -= self.fatigue_cost


class Parry(Move):
    def __init__(self, user):
        description = "Attempt to parry the next incoming attack."
        prep = 1
        execute = 1
        recoil = 5
        cooldown = 2
        fatigue_cost = 0
        if fatigue_cost <= 10:
            fatigue_cost = 10
        super().__init__(name="Parry", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=False,
                         stage_announce=["",
                                         "{} attempts to parry the next attack.".format(user.name),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=user, user=user)
        self.evaluate()

    def viable(self):
        viability = True
        if self.user.name == "Jean" and not self.user.eq_weapon:
            viability = False
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        self.stage_beat = [1,1,5,2]
        self.fatigue_cost = 75 - ((2 * self.user.endurance) + (3 * self.user.speed))
        if self.fatigue_cost <= 10:
            self.fatigue_cost = 10

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        print(self.stage_announce[1])
        self.user.states.append(states.Parrying(user))
        self.user.fatigue -= self.fatigue_cost


class Advance(Move):
    def __init__(self, user):
        description = "Get closer to a target enemy."
        prep = 0
        execute = 4
        recoil = 0
        cooldown = 3
        fatigue_cost = 0
        target = user  # this will be changed during the combat loop when the user selects his target
        super().__init__(name="Advance", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=(3,9999),
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.evaluate()

    def viable(self):
        viability = False
        for enemy, distance in self.user.combat_proximity.items():
            if distance > 3:
                viability = True
                break
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        print(self.stage_announce[1])

    def execute(self, user):
        print("{} advances on {}...".format(user.name, self.target.name))
        threshold = self.target.speed
        performance = random.randint(0,50) + user.speed
        distance = performance - threshold
        if distance < 1:
            distance = 0
        if distance == 0:
            print("{} was unable to get closer to {}!".format(user.name, self.target.name))
        else:
            if user.combat_proximity[self.target] <= distance:
                distance = user.combat_proximity[self.target] - 3
            distance = int(distance)
            print("{} got {} ft closer to {}!".format(user.name, distance, self.target.name))
            user.combat_proximity[self.target] -= distance
            user.combat_proximity[self.target] = int(user.combat_proximity[self.target])
            self.target.combat_proximity[user] = user.combat_proximity[self.target]


class Withdraw(Move):
    def __init__(self, user):
        description = "Move away from all enemies."
        prep = 0
        execute = 5
        recoil = 0
        cooldown = 4
        fatigue_cost = 0
        target = user
        super().__init__(name="Withdraw", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=False, mvrange=(0,100),
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.evaluate()

    def viable(self):
        viability = False
        for enemy, distance in self.user.combat_proximity.items():
            if distance < self.mvrange[1]:
                viability = True
                break
        if self.user.name is not "Jean":  # NPCs won't use this if their HP is greater than 20%
            hp_pcnt = self.user.hp / self.user.maxhp
            if hp_pcnt > 0.2:
                viability = False
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        print(self.stage_announce[1])

    def execute(self, user):
        print("{} attempts to fall back...".format(user.name))
        enemy_list = {}
        for enemy, distance in self.user.combat_proximity.items():
            performance = random.randint(0, 35) + (user.speed - enemy.speed)
            if performance < 1:
                performance = 0
            enemy_list[enemy] = int(performance)
        for enemy, performance in enemy_list.items():
            if (performance == 0) or (user.combat_proximity[enemy] >= self.mvrange[1]):
                print("{} was unable to get further away from {}!".format(user.name, enemy.name))
            else:
                distance = performance
                limit_distance = self.mvrange[1] - user.combat_proximity[enemy]
                if distance > limit_distance:
                    distance = limit_distance
                distance = int(distance)
                print("{} got {} ft further away from {}!".format(user.name, distance, enemy.name))
                user.combat_proximity[enemy] += distance
                user.combat_proximity[enemy] = int(user.combat_proximity[enemy])
                enemy.combat_proximity[user] = user.combat_proximity[enemy]


### PLAYER MOVES ###


class Check(Move):  # player checks the battlefield (shows enemies, allies, distances)
    def __init__(self, player):
        description = "Check your surroundings."
        prep = 0
        execute = 0
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Check", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean checks his surroundings.",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player, instant=True)

    def prep(self, user):
        for enemy, distance in user.combat_proximity.items():
            cprint("{} is {} ft from {}".format(enemy.name, int(distance), user.name), "green")
            if user.combat_list_allies:
                for ally in user.combat_list_allies:
                    if ally.name != "Jean":
                        cprint("{} is {} ft from {}".format(enemy.name, int(ally.combat_proximity[enemy]), ally.name),"cyan")
        functions.await_input()


class Wait(Move):  # player chooses how many beats he'd like to wait
    def __init__(self, player):
        description = "Wait for the right opportunity to make your move."
        prep = 0
        execute = 0
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Wait", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean is waiting.",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def execute(self, player):
        duration = ''
        while functions.is_input_integer(duration) == False:
            duration = input("Number of beats to wait (min 3, max 10): ", )
            if functions.is_input_integer(duration):
                duration = int(duration)
                if duration > 10 or duration < 3:
                    cprint("You must enter a duration between 3 and 10 beats.", "red")
                    duration = ''
        self.stage_beat[2] = duration - 2


class Attack(Move):  # basic attack function, always uses equipped weapon, player only
    def __init__(self, player):
        description = "Strike at your enemy with your equipped weapon."
        prep = int(50 / player.speed)  # starting prep of 5
        if prep < 1:
            prep = 1
        execute = 1
        recoil = 1  # modified later, based on player weapon
        cooldown = 5 - int(player.speed/10)
        if cooldown < 0:
            cooldown = 0
        weapon = "fist"  # modified later, based on player weapon
        fatigue_cost = 100 - (5 * player.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        mvrange = (0,5)
        super().__init__(name="Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean winds up for a strike...",
                                         colored("Jean strikes with his " + weapon + "!", "green"),
                                         "Jean braces himself as his weapon recoils.",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player)
        self.evaluate()

    def viable(self):
        viability = False
        has_weapon = False
        enemy_near = False
        if self.user.eq_weapon:
            has_weapon = True
            min = self.mvrange[0]
            max = self.mvrange[1]
            for enemy, distance in self.user.combat_proximity.items():
                if min < distance < max:
                    enemy_near = True
                    break

        if has_weapon and enemy_near:
            viability = True
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = 0
        recoil = 0
        mvrange = (0,5)
        if self.user.eq_weapon:
            weapon_name = self.user.eq_weapon.name
            self.stage_announce[1] = colored("Jean strikes with his " + weapon_name + "!", "green")
            power = self.user.eq_weapon.damage + \
                (self.user.strength * self.user.eq_weapon.str_mod) + \
                (self.user.finesse * self.user.eq_weapon.fin_mod)
            recoil = int(1 + self.user.eq_weapon.weight)
            mvrange = self.user.eq_weapon.wpnrange
        prep = int(50 / self.user.speed)  # starting prep of 5
        if prep < 1:
            prep = 1
        execute = 1
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 100 - (5 * self.user.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10

        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = mvrange

    def execute(self, player):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        print(self.stage_announce[1])
        if self.viable():
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if hit_chance < 5:  # Minimum value for hit chance
                hit_chance = 5
        else:
            hit_chance = -1  # if attacking is no longer viable (enemy is out of range), then auto miss
        roll = random.randint(0, 100)
        damage = ((self.power - self.target.protection) * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        player.combat_exp += 10
        if hit_chance >= roll:  # a hit!
            if self.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class Rest(Move):  # standard rest to restore fatigue.
    def __init__(self, player):
        description = "Rest for a moment to restore fatigue."
        prep = 1
        execute = 1
        recoil = 2
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Rest", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean relaxes his muscles for a moment.",
                                         colored("Jean is resting.", "green"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def viable(self):
        viability = True
        if self.user.fatigue >= self.user.maxfatigue:
            viability = False
        return viability

    def execute(self, player):
        print(self.stage_announce[1])
        recovery_amt = (player.maxfatigue * 0.4) * random.uniform(0.8, 1.2)
        recovery_amt = int(recovery_amt)
        if recovery_amt > player.maxfatigue - player.fatigue:
            recovery_amt = player.maxfatigue - player.fatigue
        player.fatigue += recovery_amt
        cprint("You recovered {} FP!".format(recovery_amt), "green")
        player.combat_exp += 2


class Use_Item(Move):
    def __init__(self, player):
        description = "Use an item from your inventory."
        prep = 1
        execute = 1
        recoil = 1
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Use Item", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean opens his bag.",
                                         "",
                                         "Jean closes his bag.",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def viable(self):
        viability = True
        if not self.user.inventory:
            viability = False
        else:
            for item in self.user.inventory:
                if item.type == "Consumable" or "Special":
                    viability = True
                    break
        return viability

    def execute(self, player):
        player.use_item() # opens the category view for the standard "use item" action
        player.combat_exp += 1

### NPC MOVES ###

class NPC_Attack(Move): #basic attack function, NPCs only
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        if npc.target == None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="NPC_Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                                         colored("{} lashes out at {} with "
                                                 "extreme violence!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        min = self.mvrange[0]
        max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if min < distance < max:
                viability = True
                break

        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(0.8, 1.2))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 1
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 100 - (5 * self.user.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                          colored("{} lashes out at {} with "
                                  "extreme violence!".format(npc.name, self.target.name), "red"),
                          "{} recoils from the attack.".format(npc.name),
                          ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (95 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if self.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class NPC_Rest(Move):  # standard rest to restore fatigue for NPCs.
    def __init__(self, npc):
        description = "Rest for a moment to restore fatigue."
        prep = 0
        execute = 1
        recoil = 2
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Rest", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["{} rests for a moment.".format(npc.name),
                                         colored("{} is resting.".format(npc.name), "white"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=npc, user=npc)

    def execute(self, npc):
        print(self.stage_announce[1])
        recovery_amt = (self.user.maxfatigue * 0.25) * random.uniform(0.8, 1.2)
        recovery_amt = int(recovery_amt)
        if recovery_amt > self.user.maxfatigue - self.user.fatigue:
            recovery_amt = self.user.maxfatigue - self.user.fatigue
        self.user.fatigue += recovery_amt


class NPC_Idle(Move):  # NPC does nothing for a few beats.
    def __init__(self, npc):
        description = "What?"
        prep = 0
        execute = 3
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Idle", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["",
                                         str(npc.name + npc.idle_message),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=npc, user=npc)

    def execute(self, npc):
        print(self.stage_announce[1])


class Gorran_Club(Move):  # Gorran's special club attack! Massive damage, long recoil
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 2
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        if npc.target == None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="NPC_Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} grips his massive club in preparation to strike!".format(npc.name), "red"),
                                         colored("{} swings his club mightily at {}!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils heavily from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        min = self.mvrange[0]
        max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if min < distance < max:
                viability = True
                break
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(1.5, 3))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 2
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        recoil += 5
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        cooldown += 3
        fatigue_cost = 100 - (3 * self.user.endurance)
        if fatigue_cost <= 25:
            fatigue_cost = 25
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce=[colored("{} grips his massive club in preparation to strike!".format(npc.name), "red"),
                             colored("{} swings his club mightily at {}!".format(npc.name, npc.target.name), "red"),
                             "{} recoils heavily from the attack.".format(npc.name),
                             ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (105 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if self.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost