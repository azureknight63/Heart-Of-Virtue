"""
Combat moves to be used within combat module. Moves are objects generated by player/AI action during combat.
"""
from termcolor import colored, cprint
import random, time
import states, functions, items


class Move:  # master class for all moves
    def __init__(self, name, description, xp_gain, current_stage, beats_left,
                 stage_announce, target, user, stage_beat, targeted, mvrange=(0,9999), heat_gain=0, fatigue_cost=0,
                 instant=False, verbose_targeting=False):
        self.name = name
        self.description = description
        self.xp_gain = xp_gain
        self.heat_gain = heat_gain
        self.current_stage = current_stage
        self.stage_beat = stage_beat
        self.beats_left = beats_left
        self.stage_announce = stage_announce
        self.fatigue_cost = fatigue_cost
        self.target = target  # can be the same as the user in abilities with no targets
        self.user = user
        self.targeted = targeted  # Is the move targeted at something?
        self.verbose_targeting = verbose_targeting  # If set to true, the target menu will always appear even with 1 target and will show additional info
        self.interrupted = False  # When a move is interrupted, skip all remaining actions for that move, set the
        # move's cooldown
        self.initialized = False
        self.usercolor = "white"
        self.targetcolor = "white"
        self.mvrange = mvrange  # tuple containing the min and max ranges for the move
        self.instant = instant  # moves flagged as instant do not allow any beats to pass before completing all stages
        self.weight = 1  # only used by NPCs to determine the chance that move is selected for use

    def viable(self):
        '''Check arbitrary conditions to see if the move is available for use; return True or False'''
        viability = True
        return viability

    def process_stage(self, user):
        if user.current_move == self:
            if self.current_stage == 0:
                self.prep(user)
            elif self.current_stage == 1:
                self.execute(user)
            elif self.current_stage == 2:
                self.recoil(user)
            elif self.current_stage == 3:
                self.cooldown(user)  # the cooldown stage will typically never be rewritten,
                # so this will usually just pass

    def cast(self, user): # this is what happens when the ability is first chosen by the player
        self.current_stage = 0 # initialize prep stage
        if self.stage_announce[0] != "":
            print(self.stage_announce[0])  # Print the prep announce message for the move
        self.beats_left = self.stage_beat[0]

    def advance(self, user):
        self.evaluate()
        if user.current_move == self or self.current_stage == 3:  # only advance the move if it's the player's
            # current move or if it's in cooldown
            #print("###DEBUG: " + user.name + " " + self.name + " STAGE: " + str(self.current_stage) +
            #      " BEATS LEFT: " + str(self.beats_left))
            if self.beats_left > 0:
                self.beats_left -= 1
            else:
                while self.beats_left == 0:  # this loop will advance stages until the current stage has a beat count,
                    # effectively skipping unused stages; if the move is instant, pretend all beat counts are 0!
                    self.process_stage(user)
                    self.current_stage += 1  # switch to next stage
                    if self.current_stage == 3:  # when the move enters cooldown, detach it from the player so he can
                        # do something else.
                        user.current_move = None
                        self.initialized = False
                    if self.current_stage > 3: # if the move is coming out of cooldown, switch back to the prep stage
                        # and break the while loop
                        self.current_stage = 0
                        self.beats_left = self.stage_beat[self.current_stage]
                        break
                    self.beats_left = self.stage_beat[self.current_stage]  # set beats remaining for current stage

    def prep(self, user): #what happens during these stages. Each move will overwrite prep/execute/recoil/cooldown
        # depending on whether something is supposed to happen at that stage
        # print("######{}: I'm in the prep stage now".format(self.name)) #debug message
        pass

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        if self.stage_announce[1] != "":
            print(self.stage_announce[1])

    def recoil(self, user):
        # print("######{}: I'm in the recoil stage now".format(self.name)) #debug message
       if self.stage_announce[2] != "":
            print(self.stage_announce[2])

    def cooldown(self, user):
        # print("######{}: I'm in the cooldown stage now".format(self.name)) #debug message
        pass

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        pass

    def prep_colors(self):  # prepares usercolor, targetcolor for prints
        player = ""
        if self.user.name == "Jean":
            player = self.user
        else:
            if not self.user.friend:
                self.usercolor = "magenta"
            else:
                self.usercolor = "cyan"
        if self.target.name == "Jean":
            player = self.target
        else:
            if not self.target.friend:
                self.targetcolor = "magenta"
            else:
                self.targetcolor = "cyan"
        if self.user == player:
            self.usercolor = "green"
        if self.target == player:
            self.targetcolor = "green"

    def parry(self):
        print(colored(self.target.name, self.targetcolor) + colored(" parried the attack from ", "red") +
              colored(self.user.name, self.usercolor) + colored("!", "red"))
        self.stage_beat[2] += 10  # add stagger time to the user
        if self.target.name == "Jean":
            self.target.change_heat(1.4)
            self.target.combat_exp[self.user.eq_weapon.subtype] += 15
        if self.user.name == "Jean":
            self.user.change_heat(0.75)

    def hit(self, damage, glance):
        if damage > 0:
            if glance:
                print(colored(self.user.name, self.usercolor) + colored(" just barely hit ", "yellow") +
                      colored(self.target.name, self.targetcolor) + colored(" for ", "yellow") +
                      colored(damage, "red") + colored(" damage!", "yellow"))
            else:
                print(colored(self.user.name, self.usercolor) + colored(" struck ", "yellow") +
                      colored(self.target.name, self.targetcolor) + colored(" for ", "yellow") +
                      colored(damage, "red") + colored(" damage!", "yellow"))
            self.target.hp -= damage
            if self.user.name == "Jean":
                self.user.change_heat(1.25)
                self.user.combat_exp[self.user.eq_weapon.subtype] += (damage / 4)
            if self.target.name == "Jean":
                self.target.change_heat(
                    1 - (damage / self.target.maxhp))  # reduce heat by the percentage of dmg done to maxhp
                self.target.combat_exp["Basic"] += 15
        elif damage == 0:
            print(colored(self.user.name, self.usercolor) + colored(" struck ", "yellow") +
                  colored(self.target.name, self.targetcolor) + colored(" but did no damage!", "yellow"))
        else:
            cprint("{} struck {}, but {} absorbed {} damage!".format(colored(self.user.name, self.usercolor), colored(self.target.name, self.targetcolor),
                   colored(self.target.name, self.targetcolor), colored(damage, "red")), "yellow")
            if self.user.name == "Jean":
                self.user.change_heat(0.75)
            if self.target.name == "Jean":
                self.target.change_heat(1.25)
                self.target.combat_exp["Basic"] += 15

    def miss(self):
        print(colored(self.user.name, self.usercolor) + "'s attack just missed!")
        if self.target.name == "Jean":
            for state in self.target.states:
                if state.name == "Dodging":
                    self.target.change_heat(1.25)
                    self.target.combat_exp["Basic"] += 10
                    break
            self.target.change_heat(1.1)
            self.target.combat_exp["Basic"] += 5
        if self.user.name == "Jean":
            self.user.change_heat(0.85)

### ANY MOVES ###

class Dodge(Move):
    def __init__(self, user):
        description = "Prepare to dodge incoming attacks."
        prep = 1
        execute = 1
        recoil = 5
        cooldown = 2
        fatigue_cost = 0
        super().__init__(name="Dodge", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=False,
                         stage_announce=["",
                                         "{} tenses in preparation to avoid attacks.".format(user.name),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=user, user=user)
        self.evaluate()

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        self.stage_beat = [1,1,5,2]
        self.fatigue_cost = 75 - ((2 * self.user.endurance) + (3 * self.user.speed))
        if self.fatigue_cost <= 10:
            self.fatigue_cost = 10

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        print(self.stage_announce[1])
        for state in self.user.states:  # remove any other instances of Dodging
            if isinstance(state, states.Dodging):
                self.user.states.remove(state)
        self.user.states.append(states.Dodging(user))
        self.user.fatigue -= self.fatigue_cost


class Parry(Move):
    def __init__(self, user):
        description = "Attempt to parry the next incoming attack."
        prep = 1
        execute = 1
        recoil = 5
        cooldown = 2
        fatigue_cost = 0
        if fatigue_cost <= 10:
            fatigue_cost = 10
        super().__init__(name="Parry", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=False,
                         stage_announce=["",
                                         "{} attempts to parry the next attack.".format(user.name),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=user, user=user)
        self.evaluate()

    def viable(self):
        viability = True
        if self.user.name == "Jean" and not self.user.eq_weapon:
            viability = False
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        self.stage_beat = [1,1,5,2]
        self.fatigue_cost = 75 - ((2 * self.user.endurance) + (3 * self.user.speed))
        if self.fatigue_cost <= 10:
            self.fatigue_cost = 10

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        print(self.stage_announce[1])
        self.user.states.append(states.Parrying(user))
        self.user.fatigue -= self.fatigue_cost


class Advance(Move):
    def __init__(self, user):
        description = "Get closer to a target enemy."
        prep = 0
        execute = 4
        recoil = 0
        cooldown = 3
        fatigue_cost = 0
        target = user  # this will be changed during the combat loop when the user selects his target
        super().__init__(name="Advance", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=(1,9999),
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.evaluate()

    def viable(self):
        viability = False
        for enemy, distance in self.user.combat_proximity.items():
            if distance > 0:
                viability = True
                break
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        print(self.stage_announce[1])

    def execute(self, user):
        print("{} advances on {}...".format(user.name, self.target.name))
        threshold = self.target.speed
        performance = random.randint(0,50) + user.speed
        distance = performance - threshold
        if distance < 1:
            distance = 0
        if distance == 0:
            print("{} was unable to get closer to {}!".format(user.name, self.target.name))
        else:
            if user.combat_proximity[self.target] <= distance:
                distance = user.combat_proximity[self.target] - 3
            distance = int(distance)
            print("{} got {} ft closer to {}!".format(user.name, distance, self.target.name))
            user.combat_proximity[self.target] -= distance
            user.combat_proximity[self.target] = int(user.combat_proximity[self.target])
            self.target.combat_proximity[user] = user.combat_proximity[self.target]


class Withdraw(Move):
    def __init__(self, user):
        description = "Move away from all enemies."
        prep = 0
        execute = 5
        recoil = 0
        cooldown = 4
        fatigue_cost = 0
        target = user
        super().__init__(name="Withdraw", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=False, mvrange=(0,100),
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.evaluate()

    def viable(self):
        viability = False
        for enemy, distance in self.user.combat_proximity.items():
            if distance < self.mvrange[1]:
                viability = True
                break
        if self.user.name is not "Jean":  # NPCs won't use this if their HP is greater than 20%
            hp_pcnt = self.user.hp / self.user.maxhp
            if hp_pcnt > 0.2:
                viability = False
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        print(self.stage_announce[1])

    def execute(self, user):
        print("{} attempts to fall back...".format(user.name))
        enemy_list = {}
        for enemy, distance in self.user.combat_proximity.items():
            performance = random.randint(0, 35) + (user.speed - enemy.speed)
            if performance < 1:
                performance = 0
            enemy_list[enemy] = int(performance)
        for enemy, performance in enemy_list.items():
            if (performance == 0) or (user.combat_proximity[enemy] >= self.mvrange[1]):
                print("{} was unable to get further away from {}!".format(user.name, enemy.name))
            else:
                distance = performance
                limit_distance = self.mvrange[1] - user.combat_proximity[enemy]
                if distance > limit_distance:
                    distance = limit_distance
                distance = int(distance)
                print("{} got {} ft further away from {}!".format(user.name, distance, enemy.name))
                user.combat_proximity[enemy] += distance
                user.combat_proximity[enemy] = int(user.combat_proximity[enemy])
                enemy.combat_proximity[user] = user.combat_proximity[enemy]


### PLAYER MOVES ###


class Check(Move):  # player checks the battlefield (shows enemies, allies, distances)
    def __init__(self, player):
        description = "Check your surroundings."
        prep = 0
        execute = 0
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Check", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean checks his surroundings.",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player, instant=True)

    def prep(self, user):
        for enemy, distance in user.combat_proximity.items():
            cprint("{} is {} ft from {}".format(enemy.name, int(distance), user.name), "green")
            if user.combat_list_allies:
                for ally in user.combat_list_allies:
                    if ally.name != "Jean":
                        cprint("{} is {} ft from {}".format(enemy.name, int(ally.combat_proximity[enemy]), ally.name),"cyan")
        functions.await_input()


class Wait(Move):  # player chooses how many beats he'd like to wait
    def __init__(self, player):
        description = "Wait for the right opportunity to make your move."
        prep = 0
        execute = 0
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Wait", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean is waiting.",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def execute(self, player):
        duration = ''
        while functions.is_input_integer(duration) == False:
            duration = input("Number of beats to wait (min 3, max 10): ", )
            if functions.is_input_integer(duration):
                duration = int(duration)
                if duration > 10 or duration < 3:
                    cprint("You must enter a duration between 3 and 10 beats.", "red")
                    duration = ''
        self.stage_beat[2] = duration - 2


class Attack(Move):  # basic attack function, always uses equipped weapon, player only
    def __init__(self, player):
        description = "Strike at your enemy with your equipped weapon."
        prep = int(50 / player.speed)  # starting prep of 5
        if prep < 1:
            prep = 1
        execute = 1
        recoil = 1  # modified later, based on player weapon
        cooldown = 5 - int(player.speed/10)
        if cooldown < 0:
            cooldown = 0
        weapon = "fist"  # modified later, based on player weapon
        fatigue_cost = 100 - (5 * player.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        mvrange = (0,5)
        super().__init__(name="Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean winds up for a strike...",
                                         colored("Jean strikes with his " + weapon + "!", "green"),
                                         "Jean braces himself as his weapon recoils.",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player)
        self.power = 0
        self.evaluate()
        self.base_damage_type = items.get_base_damage_type(player.eq_weapon)

    def viable(self):
        viability = False
        has_weapon = False
        enemy_near = False
        if self.user.eq_weapon:
            has_weapon = True
            min = self.mvrange[0]
            max = self.mvrange[1]
            for enemy, distance in self.user.combat_proximity.items():
                if min <= distance <= max:
                    enemy_near = True
                    break

        if has_weapon and enemy_near:
            viability = True
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = self.user.eq_weapon.damage + \
                (self.user.strength * self.user.eq_weapon.str_mod) + \
                (self.user.finesse * self.user.eq_weapon.fin_mod)

        prep = int((40 + (self.user.eq_weapon.weight * 3)) / self.user.speed)  # starting prep of 5
        if prep < 1:
            prep = 1

        execute = 1

        cooldown = (2 + self.user.eq_weapon.weight) - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0

        recoil = int(1 + (self.user.eq_weapon.weight / 2))

        fatigue_cost = (70 + (self.user.eq_weapon.weight * 10) - (5 * self.user.endurance))
        if fatigue_cost <= 10:
            fatigue_cost = 10

        mvrange = self.user.eq_weapon.wpnrange

        weapon_name = self.user.eq_weapon.name
        self.stage_announce[1] = colored("Jean strikes with his " + weapon_name + "!", "green")
        self.power = power
        self.stage_beat = [prep, execute, recoil, cooldown]
        self.fatigue_cost = fatigue_cost
        self.mvrange = mvrange
        self.base_damage_type = items.get_base_damage_type(self.user.eq_weapon)

    def execute(self, player):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        print(self.stage_announce[1])
        if self.viable():
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if hit_chance < 5:  # Minimum value for hit chance
                hit_chance = 5
        else:
            hit_chance = -1  # if attacking is no longer viable (enemy is out of range), then auto miss
        roll = random.randint(0, 100)
        damage = (((self.power * self.target.resistance[self.base_damage_type]) - self.target.protection) * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        player.combat_exp["Basic"] += 10
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class Rest(Move):  # standard rest to restore fatigue.
    def __init__(self, player):
        description = "Rest for a moment to restore fatigue."
        prep = 1
        execute = 1
        recoil = 2
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Rest", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean relaxes his muscles for a moment.",
                                         colored("Jean is resting.", "green"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def viable(self):
        viability = True
        if self.user.fatigue >= self.user.maxfatigue:
            viability = False
        return viability

    def execute(self, player):
        print(self.stage_announce[1])
        recovery_amt = (player.maxfatigue * 0.4) * random.uniform(0.8, 1.2)
        recovery_amt = int(recovery_amt)
        if recovery_amt > player.maxfatigue - player.fatigue:
            recovery_amt = player.maxfatigue - player.fatigue
        player.fatigue += recovery_amt
        cprint("You recovered {} FP!".format(recovery_amt), "green")
        player.combat_exp["Basic"] += 2


class Use_Item(Move):
    def __init__(self, player):
        description = "Use an item from your inventory."
        prep = 1
        execute = 1
        recoil = 1
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Use Item", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["Jean opens his bag.",
                                         "",
                                         "Jean closes his bag.",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def viable(self):
        viability = True
        if not self.user.inventory:
            viability = False
        else:
            for item in self.user.inventory:
                if item.type == "Consumable" or "Special":
                    viability = True
                    break
        return viability

    def execute(self, player):
        player.use_item() # opens the category view for the standard "use item" action
        player.combat_exp["Basic"] += 1


class Slash(Move):  # Slashing-type attack using the equipped weapon; available only to Daggers, Swords, and Stars.
    def __init__(self, player):
        description = "Slash at your enemy with your equipped weapon. Slightly stronger than a standard attack."
        prep = 1
        execute = 1
        recoil = 1  # modified later, based on player weapon
        cooldown = 0
        weapon = "fist"  # modified later, based on player weapon
        fatigue_cost = 0
        mvrange = (0,5)
        super().__init__(name="Slash", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean winds up for a strike...",
                                         colored("Jean slashes with his " + weapon + "!", "green"),
                                         "Jean braces himself as his weapon recoils.",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player)
        self.power = 0
        self.evaluate()
        self.base_damage_type = "slashing"

    def viable(self):
        viability = False
        has_weapon = False
        enemy_near = False
        allowed_subtypes = ["Dagger", "Sword", "Stars"]
        if self.user.eq_weapon:
            if self.user.eq_weapon.subtype in allowed_subtypes:
                has_weapon = True
            min = self.mvrange[0]
            max = self.mvrange[1]
            for enemy, distance in self.user.combat_proximity.items():
                if min <= distance <= max:
                    enemy_near = True
                    break

        if has_weapon and enemy_near:
            viability = True
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.eq_weapon.damage + 5) + \
                (self.user.strength * self.user.eq_weapon.str_mod) + \
                (self.user.finesse * self.user.eq_weapon.fin_mod)

        prep = int((40 + (self.user.eq_weapon.weight * 3)) / self.user.speed)  # starting prep of 5
        if prep < 1:
            prep = 1

        execute = 1

        cooldown = (3 + self.user.eq_weapon.weight) - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0

        recoil = int(1 + (self.user.eq_weapon.weight / 2))

        fatigue_cost = (85 + (self.user.eq_weapon.weight * 10) - (5 * self.user.endurance))
        if fatigue_cost <= 10:
            fatigue_cost = 10

        mvrange = self.user.eq_weapon.wpnrange

        weapon_name = self.user.eq_weapon.name
        self.stage_announce[1] = colored("Jean strikes with his " + weapon_name + "!", "green")
        self.power = power
        self.stage_beat = [prep, execute, recoil, cooldown]
        self.fatigue_cost = fatigue_cost
        self.mvrange = mvrange

    def execute(self, player):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        print(self.stage_announce[1])
        if self.viable():
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if hit_chance < 5:  # Minimum value for hit chance
                hit_chance = 5
        else:
            hit_chance = -1  # if attacking is no longer viable (enemy is out of range), then auto miss
        roll = random.randint(0, 100)
        damage = (((self.power * self.target.resistance[self.base_damage_type]) - self.target.protection) * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        player.combat_exp[player.eq_weapon.subtype] += 10
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class TacticalPositioning(Move):
    def __init__(self, user):
        description = "Fine-tune the distance between yourself and a target enemy."
        prep = 0
        execute = 4
        recoil = 0
        cooldown = 3
        fatigue_cost = 0
        target = user  # this will be changed during the combat loop when the user selects his target
        super().__init__(name="Tactical Positioning", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=(0,100),
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.distance = 0
        self.evaluate()

    def viable(self):
        return True

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        distance = ''
        while not functions.is_input_integer(distance):
            distance = input("Enter the desired distance between yourself and your target (min {}, max {}): ".format(self.mvrange[0], self.mvrange[1]), )
            if functions.is_input_integer(distance):
                distance = int(distance)  # forced typecasting is required because inputs are strings; is_input_integer only tests if the entered string
                                            # follows the integer pattern (numeral, no decimal)
                if distance > 100 or distance < 0:
                    cprint("You must enter a distance between {} and {}.".format(self.mvrange[0], self.mvrange[1]), "red")
                    distance = ''
        self.distance = distance

    def execute(self, user):
        print("{} adjusts his position in relation to {}...".format(user.name, self.target.name))
        # modify the target position inputted by the player by some variance
        variance = (self.target.speed * random.uniform(0.5, 1.5)) - (self.user.speed * random.uniform(0.5, 1.5))
        if variance < 1:
            variance = 1
        variance = int(variance)
        targetposition = random.randint(self.distance - variance, self.distance + variance)
        if targetposition < self.mvrange[0]:
            targetposition = self.mvrange[0]
        if targetposition > self.mvrange[1]:
            targetposition = self.mvrange[1]
        # next, get the distance between the user and the target
        currentposition = int(user.combat_proximity[self.target])
        # now, evaluate the distance to move and execute
        distance = currentposition - targetposition
        if distance > 0:  # player will move closer to target
            print("{} got {} ft closer to {}!".format(user.name, distance, self.target.name))
            user.combat_proximity[self.target] -= distance
            user.combat_proximity[self.target] = int(user.combat_proximity[self.target])
            self.target.combat_proximity[user] = user.combat_proximity[self.target]
            user.combat_exp["Basic"] += 5
        elif distance < 0:  # player will move further away from target
            print("{} got {} ft further away from {}!".format(user.name, distance, self.target.name))
            user.combat_proximity[self.target] += distance
            user.combat_proximity[self.target] = int(user.combat_proximity[self.target])
            self.target.combat_proximity[user] = user.combat_proximity[self.target]
            user.combat_exp["Basic"] += 5
        else:
            print("{} was unable to get closer to {}!".format(user.name, self.target.name))

            
class ShootBow(Move):  # ranged attack with a bow, player only. Requires having arrows in inventory; this is checked when available skills are evaluated in combat.py
    def __init__(self, player):
        description = "Fire an arrow at a target enemy. You must have arrows in your inventory to use. " \
                      "If you have multiple types of arrows, you may choose which type to fire."
        prep = 10
        execute = 1
        recoil = 1  # bows do not have significant recoil
        cooldown = 3
        fatigue_cost = 100 - (5 * player.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        mvrange = (6,50)
        super().__init__(name="Shoot Bow", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean reaches into his quiver.",
                                         colored("Jean lets his arrow fly!", "green"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player, verbose_targeting=True)
        self.arrow = items.WoodenArrow()  # modified later, based on player arrow type fired; arrow type chosen at prep stage
        self.power = 0
        self.base_damage_type = items.get_base_damage_type(player.eq_weapon)
        self.accuracy = 1.0
        self.base_range = 20
        self.decay = 0.05
        self.evaluate()

    def calculate_hit_chance(self, enemy): # estimate the hit chance for enemy and return as a string (ex "48%")
        hit_chance = 2
        min = self.mvrange[0]
        effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
        max = effective_range
        target_distance = self.user.combat_proximity[enemy]
        if min <= target_distance <= max:  # check if target is still in range
            hit_chance = (98 - enemy.finesse) + self.user.finesse
            if target_distance > self.user.eq_weapon.range_base:
                accuracy_decay = (target_distance - self.user.eq_weapon.range_base) * self.decay
                hit_chance -= accuracy_decay
            if hit_chance < 2:  # Minimum value for hit chance
                hit_chance = 2
        #todo cut hit chance in half if an enemy is within melee range
        return "{}%".format(hit_chance)

    def viable(self):
        viability = False
        has_bow = False
        enemy_in_range = False
        has_arrows = False
        if self.user.eq_weapon.subtype == "Bow":
            has_bow = True
            min = self.mvrange[0]
            effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
            max = effective_range
            for enemy, distance in self.user.combat_proximity.items():
                if min <= distance <= max:
                    enemy_in_range = True
                    break

        if hasattr(self.user, "inventory"):
            for item in self.user.inventory:
                if item.subtype == "Arrow":
                    has_bow = True
                    break

        if has_bow and enemy_in_range and has_arrows:
            viability = True
        return viability

    def prep(self, player):
        # first, check if there is more than one type of arrow. If so, build a menu, else skip to modifying effects
        arrowtypes = []
        for arrowtype in self.user.inventory:
            if arrowtype.subtype == "Arrow":
                if arrowtype.count > 0:  # in case the arrow stack hasn't had a chance to remove itself, check the count
                    arrowtypes.append(arrowtype)
        if len(arrowtypes) > 1:  # build our menu
            cprint("Select an arrow type...", "cyan")
            for i, v in enumerate(arrowtypes):
                print(colored(str(i) + ": " + v.name, "cyan") + "(" + v.helptext + ")")
            arrow_selection = None
            while not arrow_selection:
                arrow_selection = input(colored('Selection: ', "cyan"))
                if functions.is_input_integer(arrow_selection):
                    arrow_selection = int(arrow_selection)
                    if arrow_selection < len(arrowtypes):
                        self.arrow = arrowtypes[arrow_selection]
                        print("Jean knocks a {} and takes aim!".format(self.arrow.name.lower()))
                        self.base_range = player.eq_weapon.range_base * self.arrow.range_base_modifier
                        self.decay = player.eq_weapon.range_decay * self.arrow.range_decay_modifier
                        self.base_damage_type = items.get_base_damage_type(self.arrow)  # in case the arrow has a different base damage type than Piercing
                        self.power = self.arrow.power
                        if self.arrow.effects:
                            for effect in self.arrow.effects:
                                if effect.trigger == "prep":
                                    effect.process()
                        break
                cprint("Invalid selection! Please try again.", "red")
                arrow_selection = None
        else:
            self.arrow = arrowtypes[0]
            print("Jean knocks a {} and takes aim!".format(self.arrow.name.lower()))
            self.base_range = player.eq_weapon.range_base * self.arrow.range_base_modifier
            self.decay = player.eq_weapon.range_decay * self.arrow.range_decay_modifier
            self.base_damage_type = items.get_base_damage_type(self.arrow)  # in case the arrow has a different base damage type than Piercing
            self.power = self.arrow.power
            if self.arrow.effects:
                for effect in self.arrow.effects:
                    if effect.trigger == "prep":
                        effect.process()

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = 0
        prep = int(100 / ((self.user.speed * 0.7) + (self.user.strength * 0.3)))  # starting prep of 10
        if prep < 1:
            prep = 1
        execute = 1
        recoil = 1
        cooldown = 3 - int(self.user.speed/20)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 100 - (5 * self.user.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        #effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
        #weapon_name = self.user.eq_weapon.name
        #self.stage_announce[1] = colored("Jean lets his " + weapon_name + " fly!", "green") ### TBD when arrow is selected
        self.power = power
        self.stage_beat = [prep, execute, recoil, cooldown]
        self.fatigue_cost = fatigue_cost
        #self.mvrange = (6, effective_range)
        self.base_damage_type = items.get_base_damage_type(self.arrow)
        #self.base_range = self.user.eq_weapon.range_base
        #self.decay = self.user.eq_weapon.range_decay

    def execute(self, player):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        min = self.mvrange[0]
        effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
        max = effective_range
        target_distance = player.combat_proximity[self.target]
        if min <= target_distance <= max:  # check if target is still in range
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if target_distance > self.user.eq_weapon.range_base:
                accuracy_decay = (target_distance - self.user.eq_weapon.range_base) * self.decay
                hit_chance -= accuracy_decay
            if hit_chance < 2:  # Minimum value for hit chance
                hit_chance = 2
            #todo copy your hit chance reduction for enemies within melee range
            print(self.stage_announce[1])
            #todo decrement arrow count by 1; make sure you are decrementing the right arrow type!
        else:
            print("Jean relaxes his bow as his target is no longer in range.")
            return
        roll = random.randint(0, 100)
        self.power += (self.user.finesse * self.user.eq_weapon.fin_mod)
        damage = (((self.power * self.target.resistance[self.base_damage_type]) - self.target.protection) * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        player.combat_exp["Bow"] += 10
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
                if self.arrow.effects:
                    for effect in self.arrow.effects:
                        if effect.trigger == "execute":
                            effect.process()
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


### NPC MOVES ###

class NPC_Attack(Move): #basic attack function, NPCs only
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        if npc.target == None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="NPC_Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                                         colored("{} lashes out at {} with "
                                                 "extreme violence!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        min = self.mvrange[0]
        max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if min < distance < max:
                viability = True
                break

        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(0.8, 1.2))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 1
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 100 - (5 * self.user.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                          colored("{} lashes out at {} with "
                                  "extreme violence!".format(npc.name, self.target.name), "red"),
                          "{} recoils from the attack.".format(npc.name),
                          ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (95 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class NPC_Rest(Move):  # standard rest to restore fatigue for NPCs.
    def __init__(self, npc):
        description = "Rest for a moment to restore fatigue."
        prep = 0
        execute = 1
        recoil = 2
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Rest", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["{} rests for a moment.".format(npc.name),
                                         colored("{} is resting.".format(npc.name), "white"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=npc, user=npc)

    def execute(self, npc):
        print(self.stage_announce[1])
        recovery_amt = (self.user.maxfatigue * 0.25) * random.uniform(0.8, 1.2)
        recovery_amt = int(recovery_amt)
        if recovery_amt > self.user.maxfatigue - self.user.fatigue:
            recovery_amt = self.user.maxfatigue - self.user.fatigue
        self.user.fatigue += recovery_amt


class NPC_Idle(Move):  # NPC does nothing for a few beats.
    def __init__(self, npc):
        description = "What?"
        prep = 0
        execute = 3
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Idle", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep,execute,recoil,cooldown],
                         stage_announce=["",
                                         str(npc.name + npc.idle_message),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=npc, user=npc)

    def execute(self, npc):
        print(self.stage_announce[1])


class Gorran_Club(Move):  # Gorran's special club attack! Massive damage, long recoil
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 2
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        if npc.target == None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="NPC_Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} grips his massive club in preparation to strike!".format(npc.name), "red"),
                                         colored("{} swings his club mightily at {}!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils heavily from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        min = self.mvrange[0]
        max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if min < distance < max:
                viability = True
                break
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(1.5, 3))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 2
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        recoil += 5
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        cooldown += 3
        fatigue_cost = 100 - (3 * self.user.endurance)
        if fatigue_cost <= 25:
            fatigue_cost = 25
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce=[colored("{} grips his massive club in preparation to strike!".format(npc.name), "red"),
                             colored("{} swings his club mightily at {}!".format(npc.name, npc.target.name), "red"),
                             "{} recoils heavily from the attack.".format(npc.name),
                             ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (105 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class VenomClaw(Move): # Poisonous attack
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        if npc.target == None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="VenomClaw", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                                         colored("{} slashes at {} with "
                                                 "its venomous claws!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        min = self.mvrange[0]
        max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if min < distance < max:
                viability = True
                break

        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(0.6, 1))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 1
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 120 - (5 * self.user.endurance)
        if fatigue_cost <= 20:
            fatigue_cost = 20
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                                         colored("{} slashes at {} with "
                                                 "its venomous claws!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (95 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
                status = states.Poisoned(self.target)
                functions.inflict(status, self.target, chance=0.3)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class SpiderBite(Move):  # Poisonous attack
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        if npc.target == None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="SpiderBite", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep,execute,recoil,cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} flashes its poisonous mandibles!".format(npc.name), "red"),
                                         colored("{} bites at {} with "
                                                 "its poisonous mandibles!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        min = self.mvrange[0]
        max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if min < distance < max:
                viability = True
                break

        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(0.8, 1.2))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 1
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 120 - (5 * self.user.endurance)
        if fatigue_cost <= 20:
            fatigue_cost = 20
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} flashes its poisonous mandibles!".format(npc.name), "red"),
                                         colored("{} bites at {} with "
                                                 "its poisonous mandibles!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (95 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
                status = states.Poisoned(self.target)
                functions.inflict(status, self.target, chance=0.15)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost
