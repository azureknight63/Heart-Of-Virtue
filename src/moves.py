"""
Combat moves to be used within combat module. Moves are objects generated by player/AI action during combat.
"""
from neotermcolor import colored, cprint
import random
from src import states
import functions
import items

# from open_terminal import open_window as animation
from animations import animate_to_main_screen as animate

# Helper to ensure weapon subtype EXP pools exist (referenced in parry/hit/standard_execute_attack)

def _ensure_weapon_exp(user):
    """Guarantee combat_exp (and skill_exp if present) contain an entry for the current weapon's subtype.
    Needed when weapons are assigned directly (tests or scripted events) bypassing equip_item()."""
    try:
        wpn = getattr(user, 'eq_weapon', None)
        if wpn and hasattr(wpn, 'subtype'):
            if not hasattr(user, 'combat_exp'):
                return
            if wpn.subtype not in user.combat_exp:
                user.combat_exp[wpn.subtype] = 0
            if hasattr(user, 'skill_exp') and wpn.subtype not in user.skill_exp:
                user.skill_exp[wpn.subtype] = 0
    except Exception:
        # Silent fail to avoid disrupting combat flow if something unexpected occurs
        pass

default_animations = {
    "p": "None",  # prep
    "e": "None",  # execute
    "r": "None",  # recoil
    "c": "None"  # cooldown
}


class Move:  # master class for all moves
    def __init__(self, name, description, xp_gain, current_stage, beats_left,
                 stage_announce, target, user, stage_beat, targeted, mvrange=(0, 9999), heat_gain=0, fatigue_cost=0,
                 instant=False, verbose_targeting=False):
        self.name = name
        self.description = description
        self.xp_gain = xp_gain
        self.heat_gain = heat_gain
        self.current_stage = current_stage
        self.stage_beat = stage_beat
        self.beats_left = beats_left
        self.stage_announce = stage_announce
        self.fatigue_cost = fatigue_cost
        self.target = target  # can be the same as the user in abilities with no targets
        self.user = user
        self.targeted = targeted  # Is the move targeted at something?
        self.verbose_targeting = verbose_targeting  # If set to true, the target menu will always appear even with
        # 1 target and will show additional info
        self.interrupted = False  # When a move is interrupted, skip all remaining actions for that move, set the
        # move's cooldown
        self.initialized = False
        self.usercolor = "white"
        self.targetcolor = "white"
        self.mvrange = mvrange  # tuple containing the min and max ranges for the move
        self.instant = instant  # moves flagged as instant do not allow any beats to pass before completing all stages
        self.weight = 1  # only used by NPCs to determine the chance that move is selected for use

    def viable(self):
        """Check arbitrary conditions to see if the move is available for use; return True or False"""
        viability = True
        return viability

    def process_stage(self, user):
        if user.current_move == self:
            if self.current_stage == 0:
                self.prep(user)
            elif self.current_stage == 1:
                self.execute(user)
            elif self.current_stage == 2:
                self.recoil()
            elif self.current_stage == 3:
                self.cooldown(user)  # the cooldown stage will typically never be rewritten,
                # so this will usually just pass

    def cast(self):  # this is what happens when the ability is first chosen by the player
        self.current_stage = 0  # initialize prep stage
        if self.stage_announce[0] != "":
            print(self.stage_announce[0])  # Print the prep announce message for the move
        self.beats_left = self.stage_beat[0]

    def advance(self, user):
        self.evaluate()
        if user.current_move == self or self.current_stage == 3:  # only advance the move if it's the player's
            # current move or if it's in cooldown
            # print("###DEBUG: " + user.name + " " + self.name + " STAGE: " + str(self.current_stage) +
            #      " BEATS LEFT: " + str(self.beats_left))
            if self.beats_left > 0:
                self.beats_left -= 1
            else:
                while self.beats_left == 0:  # this loop will advance stages until the current stage has a beat count,
                    # effectively skipping unused stages; if the move is instant, pretend all beat counts are 0!
                    self.process_stage(user)
                    self.current_stage += 1  # switch to next stage
                    if self.current_stage == 3:  # when the move enters cooldown, detach it from the player so he can
                        # do something else.
                        user.current_move = None
                        self.initialized = False
                    if self.current_stage > 3:  # if the move is coming out of cooldown, switch back to the prep stage
                        # and break the while loop
                        self.current_stage = 0
                        self.beats_left = self.stage_beat[self.current_stage]
                        break
                    self.beats_left = self.stage_beat[self.current_stage]  # set beats remaining for current stage

    def prep(self, user):  # what happens during these stages. Each move will overwrite prep/execute/recoil/cooldown
        # depending on whether something is supposed to happen at that stage
        # print("######{}: I'm in the prep stage now".format(self.name)) #debug message
        pass

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        if self.stage_announce[1] != "":
            print(self.stage_announce[1])

    def recoil(self):
        # print("######{}: I'm in the recoil stage now".format(self.name)) #debug message
        if self.stage_announce[2] != "":
            print(self.stage_announce[2])

    def cooldown(self, user):
        # print("######{}: I'm in the cooldown stage now".format(self.name)) #debug message
        pass

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        pass

    def prep_colors(self):  # prepares usercolor, targetcolor for prints
        player = ""
        if self.user.name == "Jean":
            player = self.user
        else:
            if not self.user.friend:
                self.usercolor = "magenta"
            else:
                self.usercolor = "cyan"
        if self.target.name == "Jean":
            player = self.target
        else:
            if not self.target.friend:
                self.targetcolor = "magenta"
            else:
                self.targetcolor = "cyan"
        if self.user == player:
            self.usercolor = "green"
        if self.target == player:
            self.targetcolor = "green"

    def parry(self):
        print(colored(self.target.name, self.targetcolor) + colored(" parried the attack from ", "red") +
              colored(self.user.name, self.usercolor) + colored("!", "red"))
        self.stage_beat[2] += 10  # add stagger time to the user
        if self.target.name == "Jean":
            self.target.change_heat(1.4)
            _ensure_weapon_exp(self.user)
            self.target.combat_exp[self.user.eq_weapon.subtype] += 15
        if self.user.name == "Jean":
            self.user.change_heat(0.75)

    def hit(self, damage, glance):
        if damage > 0:
            if glance:
                print(colored(self.user.name, self.usercolor) + colored(" just barely hit ", "yellow") +
                      colored(self.target.name, self.targetcolor) + colored(" for ", "yellow") +
                      colored(damage, "red") + colored(" damage!", "yellow"))
            else:
                print(colored(self.user.name, self.usercolor) + colored(" struck ", "yellow") +
                      colored(self.target.name, self.targetcolor) + colored(" for ", "yellow") +
                      colored(damage, "red") + colored(" damage!", "yellow"))
            self.target.hp -= damage
            if self.user.name == "Jean":
                self.user.change_heat(1.25)
                _ensure_weapon_exp(self.user)
                self.user.combat_exp[self.user.eq_weapon.subtype] += (damage / 4)
            if self.target.name == "Jean":
                self.target.change_heat(
                    1 - (damage / self.target.maxhp))  # reduce heat by the percentage of dmg done to maxhp
                self.target.combat_exp["Basic"] += 15
        elif damage == 0:
            print(colored(self.user.name, self.usercolor) + colored(" struck ", "yellow") +
                  colored(self.target.name, self.targetcolor) + colored(" but did no damage!", "yellow"))
        else:
            cprint("{} struck {}, but {} absorbed {} damage!".format(colored(self.user.name, self.usercolor),
                                                                     colored(self.target.name, self.targetcolor),
                                                                     colored(self.target.name, self.targetcolor),
                                                                     colored(damage, "red")), "yellow")
            if self.user.name == "Jean":
                self.user.change_heat(0.75)
            if self.target.name == "Jean":
                self.target.change_heat(1.25)
                self.target.combat_exp["Basic"] += 15

    def miss(self):
        print(colored(self.user.name, self.usercolor) + "'s attack just missed!")
        if self.target.name == "Jean":
            for state in self.target.states:
                if state.name == "Dodging":
                    self.target.change_heat(1.25)
                    self.target.combat_exp["Basic"] += 10
                    break
            self.target.change_heat(1.1)
            self.target.combat_exp["Basic"] += 5
        if self.user.name == "Jean":
            self.user.change_heat(0.85)

    def standard_viability_attack(self, subtypes=()):
        """
        Standard viability loadout for a typical attack-type ability
        :return: boolean true or false
        """
        viability = False
        has_weapon = False
        enemy_near = False
        allowed_subtypes = subtypes
        if self.user.eq_weapon:
            if len(subtypes) > 0:
                if self.user.eq_weapon.subtype in allowed_subtypes:
                    has_weapon = True
            else:
                has_weapon = True
            range_min = self.mvrange[0]
            range_max = self.mvrange[1]
            for enemy, distance in self.user.combat_proximity.items():
                if range_min <= distance <= range_max:
                    enemy_near = True
                    break

        if has_weapon and enemy_near:
            viability = True
        return viability

    def standard_evaluate_attack(
            self, base_power, base_damage_type, mod_power=0,
            mod_prep=0, mod_cd=0, mod_recoil=0, mod_fatigue=0,
            mod_range_min=0, mod_range_max=0
        ):
            """
            Standard evaluation sequence for typical attack-type abilities
            :return: tuple (self.power, self.base_damage_type)
            """
            # Power calculation
            power = (
                self.user.eq_weapon.damage + base_power +
                self.user.strength * self.user.eq_weapon.str_mod +
                self.user.finesse * self.user.eq_weapon.fin_mod
            )
            if isinstance(mod_power, str) and "%" in mod_power:
                mod_power_val = int(mod_power.replace("%", ""))
                power = (power * mod_power_val) / 100
            else:
                power += int(mod_power)
            power = max(0, int(power))

            # Prep calculation
            prep = int((40 + (self.user.eq_weapon.weight * 3)) / self.user.speed)
            prep += int(mod_prep)
            prep = max(1, prep)

            execute = 1

            # Cooldown calculation
            cooldown = (3 + self.user.eq_weapon.weight) - int(self.user.speed / 10)
            cooldown += int(mod_cd)
            cooldown = max(0, cooldown)

            # Recoil calculation
            recoil = int(1 + (self.user.eq_weapon.weight / 2))
            recoil += int(mod_recoil)
            recoil = max(1, recoil)

            # Fatigue cost calculation
            fatigue_cost = (85 + (self.user.eq_weapon.weight * 10) - (5 * self.user.endurance))
            fatigue_cost += int(mod_fatigue)
            fatigue_cost = max(10, int(fatigue_cost))

            # Range calculation
            mvrange = (
                self.user.eq_weapon.wpnrange[0] + int(mod_range_min),
                self.user.eq_weapon.wpnrange[1] + int(mod_range_max)
            )

            weapon_name = self.user.eq_weapon.name
            self.stage_announce[1] = colored(f"Jean strikes with his {weapon_name}!", "green")
            self.stage_beat = [prep, execute, recoil, cooldown]
            self.fatigue_cost = fatigue_cost
            self.mvrange = mvrange

            if base_damage_type == "weapon":
                base_damage_type = items.get_base_damage_type(self.user.eq_weapon)
            return power, base_damage_type

    def standard_execute_attack(self, player, power, base_damage_type):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        print(self.stage_announce[1])
        if self.viable():
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if hit_chance < 5:  # Minimum value for hit chance
                hit_chance = 5
        else:
            hit_chance = -1  # if attacking is no longer viable (enemy is out of range), then auto miss
        roll = random.randint(0, 100)
        damage = (((power * self.target.resistance[
            base_damage_type]) - self.target.protection) * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        _ensure_weapon_exp(player)
        player.combat_exp[player.eq_weapon.subtype] += 5
        player.combat_exp["Basic"] += 5
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


"""
ANY MOVES
"""


class Dodge(Move):
    def __init__(self, user):
        description = "Prepare to dodge incoming attacks."
        prep = 1
        execute = 1
        recoil = 5
        cooldown = 2
        fatigue_cost = 0
        super().__init__(name="Dodge", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=False,
                         stage_announce=["",
                                         "{} tenses in preparation to avoid attacks.".format(user.name),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=user, user=user)
        self.evaluate()

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        self.stage_beat = [1, 1, 5, 2]
        self.fatigue_cost = 75 - ((2 * self.user.endurance) + (3 * self.user.speed))
        if self.fatigue_cost <= 10:
            self.fatigue_cost = 10

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        print(self.stage_announce[1])
        for state in self.user.states:  # remove any other instances of Dodging
            if isinstance(state, states.Dodging):
                self.user.states.remove(state)
        self.user.states.append(states.Dodging(user))
        self.user.fatigue -= self.fatigue_cost


class Parry(Move):
    def __init__(self, user):
        description = "Attempt to parry the next incoming attack."
        prep = 1
        execute = 1
        recoil = 5
        cooldown = 2
        fatigue_cost = 0
        if fatigue_cost <= 10:
            fatigue_cost = 10
        super().__init__(name="Parry", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=False,
                         stage_announce=["",
                                         "{} attempts to parry the next attack.".format(user.name),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=user, user=user)
        self.evaluate()

    def viable(self):
        viability = True
        if self.user.name == "Jean" and not self.user.eq_weapon:
            viability = False
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        self.stage_beat = [1, 1, 5, 2]
        self.fatigue_cost = 75 - ((2 * self.user.endurance) + (3 * self.user.speed))
        if self.fatigue_cost <= 10:
            self.fatigue_cost = 10

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        print(self.stage_announce[1])
        self.user.states.append(states.Parrying(user))
        self.user.fatigue -= self.fatigue_cost


class Advance(Move):
    def __init__(self, user):
        description = "Get closer to a target enemy."
        prep = 0
        execute = 4
        recoil = 0
        cooldown = 3
        fatigue_cost = 0
        target = user  # this will be changed during the combat loop when the user selects his target
        super().__init__(name="Advance", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=(1, 9999),
                         stage_announce=[f"{user.name} begins advancing...",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.evaluate()

    def viable(self):
        viability = False
        for enemy, distance in self.user.combat_proximity.items():
            if distance > 1:
                viability = True
                break
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        print(self.stage_announce[1])

    def execute(self, user):
        if not self.target.is_alive():
            self.target = None  # this is to prevent advancing on targets that were killed
            return
        print("{} advances on {}...".format(user.name, self.target.name))
        threshold = self.target.speed
        performance = random.randint(0, 50) + user.speed
        distance = performance - threshold
        if distance < 1:
            distance = 0
        if distance == 0:
            if user.name == "Jean":
                color = "red"
            else:
                color = "green"
            cprint("{} was unable to get closer to {}!".format(user.name, self.target.name), color)
        else:
            if user.combat_proximity[self.target] <= distance:
                distance = user.combat_proximity[self.target] - 3
            distance = int(distance)
            if user.name == "Jean":
                color = "green"
            else:
                color = "red"
            cprint("{} got {} ft closer to {}!".format(user.name, distance, self.target.name), color)
            user.combat_proximity[self.target] -= distance
            user.combat_proximity[self.target] = int(user.combat_proximity[self.target])
            self.target.combat_proximity[user] = user.combat_proximity[self.target]


class Withdraw(Move):
    def __init__(self, user):
        description = "Move away from all enemies."
        prep = 0
        execute = 5
        recoil = 0
        cooldown = 4
        fatigue_cost = 0
        target = user
        super().__init__(name="Withdraw", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=False, mvrange=(0, 100),
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.evaluate()

    def viable(self):
        viability = False
        for enemy, distance in self.user.combat_proximity.items():
            if distance < self.mvrange[1]:
                viability = True
                break
        if self.user.name != "Jean":  # NPCs won't use this if their HP is greater than 20%
            hp_pcnt = self.user.hp / self.user.maxhp
            if hp_pcnt > 0.2:
                viability = False
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        print(self.stage_announce[1])

    def execute(self, user):
        print("{} attempts to fall back...".format(user.name))
        enemy_list = {}
        for enemy, distance in self.user.combat_proximity.items():
            performance = random.randint(0, 35) + (user.speed - enemy.speed)
            if performance < 1:
                performance = 0
            enemy_list[enemy] = int(performance)
        for enemy, performance in enemy_list.items():
            if (performance == 0) or (user.combat_proximity[enemy] >= self.mvrange[1]):
                if user.name == "Jean":
                    color = "red"
                else:
                    color = "green"
                cprint("{} was unable to get further away from {}!".format(user.name, enemy.name), color)
            else:
                distance = performance
                limit_distance = self.mvrange[1] - user.combat_proximity[enemy]
                if distance > limit_distance:
                    distance = limit_distance
                distance = int(distance)
                if user.name == "Jean":
                    color = "green"
                else:
                    color = "red"
                cprint("{} got {} ft further away from {}!".format(user.name, distance, enemy.name), color)
                user.combat_proximity[enemy] += distance
                user.combat_proximity[enemy] = int(user.combat_proximity[enemy])
                enemy.combat_proximity[user] = user.combat_proximity[enemy]


class QuietMovement(Move):
    """
    This is a passive move; it cannot be selected while in combat.
    """

    def __init__(self, user):
        description = "Improves ability to move undetected."
        prep = 0
        execute = 0
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Quiet Movement", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=False,
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=user, user=user)
        self.evaluate()

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        pass

    def execute(self, user):
        # print("######{}: I'm in the execute stage now".format(self.name)) #debug message
        pass

    def viable(self):
        return False


class PowerStrike(Move):
    def __init__(self, user):
        description = ""
        prep = 0
        execute = 4
        recoil = 3
        cooldown = 0
        fatigue_cost = 0
        self.power = 0
        self.target = user
        mvrange = (0, 5)
        if not hasattr(user, "eq_weapon"):
            self.weapon = items.Rock()
        else:
            self.weapon = user.eq_weapon
        if not hasattr(self.weapon, "name"):
            self.weapon.name = "a rock"
        super().__init__(name="Power Strike", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["This", "will", "update", "dynamically"],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=self.target, user=user)
        self.evaluate()

    def viable(self):
        viability = False
        if hasattr(self.weapon, "subtype"):
            if not self.weapon.subtype == "Bludgeon":
                return False
        else:
            return False
        range_min = self.mvrange[0]
        range_max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if range_min < distance < range_max:
                viability = True
                break
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power_base = 25  # this is the default for determining the attack's power
        if hasattr(self.user, "damage"):
            power_base = self.user.damage
        elif hasattr(self.user, "eq_weapon"):
            self.weapon = self.user.eq_weapon
            if hasattr(self.user.eq_weapon, "damage"):
                power_base = self.user.eq_weapon.damage
        power = (power_base * random.uniform(1.5, 2.5))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 4
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        recoil += 3
        cooldown = 7 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        cooldown += 3
        fatigue_cost = 100 - (3 * self.user.endurance)
        if fatigue_cost <= 25:
            fatigue_cost = 25
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.refresh_announcements(self.user)

    def refresh_announcements(self, user):
        self.stage_announce = [colored(f"{user.name} grips {user.pronouns['possessive']} {self.weapon.name} "
                                       f"in preparation to strike!", "red"),
                               colored(f"{user.name} swings {user.pronouns['possessive']} "
                                       f"{self.weapon.name} mightily at {self.target.name}!", "red"),
                               f"{user.name} recoils heavily from the attack.",
                               ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (85 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class Jab(Move):
    def __init__(self, user):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        self.power = 0
        self.target = user
        mvrange = (0, 5)
        if not hasattr(user, "eq_weapon"):
            self.weapon = items.Fists()
        else:
            self.weapon = user.eq_weapon
        if not hasattr(self.weapon, "name"):
            self.weapon.name = "fists"
        super().__init__(name="Jab", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["This", "will", "update", "dynamically"],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=self.target, user=user)
        self.evaluate()

    def viable(self):
        return self.standard_viability_attack("Unarmed")

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.eq_weapon.damage +
                 (self.user.strength * self.user.eq_weapon.str_mod) +
                 (self.user.finesse * self.user.eq_weapon.fin_mod)) / 2
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 50 - (3 * self.user.endurance)
        if fatigue_cost <= 5:
            fatigue_cost = 5
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.refresh_announcements(self.user)

    def refresh_announcements(self, user):
        self.stage_announce = ["",
                               colored(f"{user.name} swings a swift jab!", "red"),
                               "",
                               ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


"""
PLAYER MOVES
"""


class Check(Move):  # player checks the battlefield (shows enemies, allies, distances)
    def __init__(self, player):
        description = "Check your surroundings."
        prep = 0
        execute = 0
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Check", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep, execute, recoil, cooldown],
                         stage_announce=["Jean checks his surroundings.",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player, instant=True)

    def prep(self, user):
        for enemy, distance in user.combat_proximity.items():
            cprint("{} is {} ft from {}".format(enemy.name, int(distance), user.name), "green")
            if user.combat_list_allies:
                for ally in user.combat_list_allies:
                    if ally.name != "Jean":
                        cprint("{} is {} ft from {}".format(
                            enemy.name, int(ally.combat_proximity[enemy]), ally.name), "cyan")
        functions.await_input()


class Wait(Move):  # player chooses how many beats he'd like to wait
    def __init__(self, player):
        description = "Wait for the right opportunity to make your move."
        prep = 0
        execute = 0
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Wait", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep, execute, recoil, cooldown],
                         stage_announce=["Jean is waiting.",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def execute(self, player):
        duration = ''
        while not functions.is_input_integer(duration):
            duration = input("Number of beats to wait (min 3, max 10): ", )
            if functions.is_input_integer(duration):
                duration = int(duration)
                if duration > 10 or duration < 3:
                    cprint("You must enter a duration between 3 and 10 beats.", "red")
                    duration = ''
        self.stage_beat[2] = duration - 2


class Attack(Move):  # basic attack function, always uses equipped weapon, player only
    def __init__(self, player):
        description = "Strike at your enemy with your equipped weapon."
        prep = int(50 / player.speed)  # starting prep of 5
        if prep < 1:
            prep = 1
        execute = 1
        recoil = 1  # modified later, based on player weapon
        cooldown = 5 - int(player.speed / 10)
        if cooldown < 0:
            cooldown = 0
        weapon = "fist"  # modified later, based on player weapon
        fatigue_cost = 100 - (5 * player.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        mvrange = (0, 5)
        super().__init__(name="Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean winds up for a strike...",
                                         colored("Jean strikes with his " + weapon + "!", "green"),
                                         "Jean braces himself as his weapon recoils.",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player)
        self.power = 0
        self.evaluate()
        self.base_damage_type = items.get_base_damage_type(player.eq_weapon)
        self.animations = default_animations.copy()
        self.animations["e"] = "hit.gif"

    def viable(self):
        # Re-evaluate dynamic attributes so that newly equipped weapons update power, range, and announce text
        # before viability is determined. Previously, evaluate() was only called during advance(), meaning that
        # selecting Attack right after equipping a new weapon still used stale (fists) stats.
        try:
            self.evaluate()
        except Exception:
            # Fail-safe: do not block viability list if evaluation errors; original logic proceeds
            pass
        viability = False
        has_weapon = False
        enemy_near = False
        if self.user.eq_weapon:
            has_weapon = True
            range_min = self.mvrange[0]
            range_max = self.mvrange[1]
            for enemy, distance in self.user.combat_proximity.items():
                if range_min <= distance <= range_max:
                    enemy_near = True
                    break

        if has_weapon and enemy_near:
            viability = True
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = self.user.eq_weapon.damage + \
                (self.user.strength * self.user.eq_weapon.str_mod) + \
                (self.user.finesse * self.user.eq_weapon.fin_mod)

        prep = int((40 + (self.user.eq_weapon.weight * 3)) / self.user.speed)  # starting prep of 5
        if prep < 1:
            prep = 1

        execute = 1

        cooldown = (2 + self.user.eq_weapon.weight) - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0

        recoil = int(1 + (self.user.eq_weapon.weight / 2))

        fatigue_cost = (70 + (self.user.eq_weapon.weight * 10) - (5 * self.user.endurance))
        if fatigue_cost <= 10:
            fatigue_cost = 10

        mvrange = self.user.eq_weapon.wpnrange

        weapon_name = self.user.eq_weapon.name
        self.stage_announce[1] = colored("Jean strikes with his " + weapon_name + "!", "green")
        self.power = power
        self.stage_beat = [prep, execute, recoil, cooldown]
        self.fatigue_cost = fatigue_cost
        self.mvrange = mvrange
        self.base_damage_type = items.get_base_damage_type(self.user.eq_weapon)

    def execute(self, player):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        print(self.stage_announce[1])
        if hasattr(self, "animations"):
            if self.animations["e"] != "None":
                animate(self.animations["e"], self.stage_announce[1])
        if self.viable():
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if hit_chance < 5:  # Minimum value for hit chance
                hit_chance = 5
        else:
            hit_chance = -1  # if attacking is no longer viable (enemy is out of range), then auto miss
        roll = random.randint(0, 100)
        damage = (((self.power * self.target.resistance[self.base_damage_type]) - self.target.protection)
                  * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        player.combat_exp["Basic"] += 10
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class Rest(Move):  # standard rest to restore fatigue.
    def __init__(self, player):
        description = "Rest for a moment to restore fatigue."
        prep = 1
        execute = 1
        recoil = 2
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Rest", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep, execute, recoil, cooldown],
                         stage_announce=["Jean relaxes his muscles for a moment.",
                                         colored("Jean is resting.", "green"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def viable(self):
        viability = True
        if self.user.fatigue >= self.user.maxfatigue:
            viability = False
        return viability

    def execute(self, player):
        print(self.stage_announce[1])
        recovery_amt = (player.maxfatigue * 0.4) * random.uniform(0.8, 1.2)
        recovery_amt = int(recovery_amt)
        if recovery_amt > player.maxfatigue - player.fatigue:
            recovery_amt = player.maxfatigue - player.fatigue
        player.fatigue += recovery_amt
        cprint("You recovered {} FP!".format(recovery_amt), "green")
        player.combat_exp["Basic"] += 2


class UseItem(Move):
    def __init__(self, player):
        description = "Use an item from your inventory."
        prep = 1
        execute = 1
        recoil = 1
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Use Item", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep, execute, recoil, cooldown],
                         stage_announce=["Jean opens his bag.",
                                         "",
                                         "Jean closes his bag.",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=player, user=player)

    def viable(self):
        viability = True
        if not self.user.inventory:
            viability = False
        else:
            for item in self.user.inventory:
                if item.type == "Consumable" or "Special":
                    viability = True
                    break
        return viability

    def execute(self, player):
        player.use_item()  # opens the category view for the standard "use item" action
        player.combat_exp["Basic"] += 1


class Slash(Move):  # Slashing-type attack using the equipped weapon; available only to Daggers, Swords, and Stars.
    def __init__(self, player):
        description = "Slash at your enemy with your equipped weapon. Slightly stronger than a standard attack."
        prep = 1
        execute = 1
        recoil = 1  # modified later, based on player weapon
        cooldown = 0
        weapon = "fist"  # modified later, based on player weapon
        fatigue_cost = 0
        mvrange = (0, 5)
        super().__init__(name="Slash", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean winds up for a strike...",
                                         colored("Jean slashes with his " + weapon + "!", "green"),
                                         "Jean braces himself as his weapon recoils.",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player)
        self.power = 0
        self.evaluate()
        self.base_damage_type = "slashing"

    def viable(self):
        viability = False
        has_weapon = False
        enemy_near = False
        allowed_subtypes = ["Dagger", "Sword", "Stars"]
        if self.user.eq_weapon:
            if self.user.eq_weapon.subtype in allowed_subtypes:
                has_weapon = True
            range_min = self.mvrange[0]
            range_max = self.mvrange[1]
            for enemy, distance in self.user.combat_proximity.items():
                if range_min <= distance <= range_max:
                    enemy_near = True
                    break

        if has_weapon and enemy_near:
            viability = True
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.eq_weapon.damage + 5) + \
                (self.user.strength * self.user.eq_weapon.str_mod) + \
                (self.user.finesse * self.user.eq_weapon.fin_mod)

        prep = int((40 + (self.user.eq_weapon.weight * 3)) / self.user.speed)  # starting prep of 5
        if prep < 1:
            prep = 1

        execute = 1

        cooldown = (3 + self.user.eq_weapon.weight) - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0

        recoil = int(1 + (self.user.eq_weapon.weight / 2))

        fatigue_cost = (85 + (self.user.eq_weapon.weight * 10) - (5 * self.user.endurance))
        if fatigue_cost <= 10:
            fatigue_cost = 10

        mvrange = self.user.eq_weapon.wpnrange

        weapon_name = self.user.eq_weapon.name
        self.stage_announce[1] = colored("Jean strikes with his " + weapon_name + "!", "green")
        self.power = power
        self.stage_beat = [prep, execute, recoil, cooldown]
        self.fatigue_cost = fatigue_cost
        self.mvrange = mvrange

    def execute(self, player):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        print(self.stage_announce[1])
        if self.viable():
            hit_chance = (98 - self.target.finesse) + self.user.finesse
            if hit_chance < 5:  # Minimum value for hit chance
                hit_chance = 5
        else:
            hit_chance = -1  # if attacking is no longer viable (enemy is out of range), then auto miss
        roll = random.randint(0, 100)
        damage = (((self.power * self.target.resistance[self.base_damage_type]) - self.target.protection)
                  * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        player.combat_exp[player.eq_weapon.subtype] += 10
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class PommelStrike(Move):
    """
    Quick strike using the pommel of the weapon. This kind of attack serves to fill in gap time for weapons that
    have a longer execute time on their normal or special attacks. It also has a small chance to stun the target.
    """

    def __init__(self, player):
        description = "Quick strike using the pommel of the weapon."
        prep = 1
        execute = 1
        recoil = 1  # modified later, based on player weapon
        cooldown = 2
        weapon = "fist"  # modified later, based on player weapon
        fatigue_cost = 0
        mvrange = (0, 5)
        super().__init__(name="Pommel Strike", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean quickly turns his weapon...",
                                         colored("Jean quickly strikes with the pommel of his {}!".format(weapon),
                                                 "green"),
                                         "Jean braces himself from the recoil of his attack.", ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player)
        self.power = 0  # enter the base damage bonus of the attack
        self.evaluate()
        self.base_damage_type = "crushing"

    def viable(self):
        viability = self.standard_viability_attack(("Axe", "Pick", "Scythe", "Spear", "Hammer", "Sword"))
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        evaluation = self.standard_evaluate_attack(self.power, self.base_damage_type,
                                                   mod_prep=(-1 * (self.user.eq_weapon.weight * 3)))
        self.power = evaluation[0]
        self.base_damage_type = evaluation[1]

    def execute(self, player):
        self.standard_execute_attack(player, self.power, self.base_damage_type)


class TacticalPositioning(Move):
    def __init__(self, user):
        description = "Fine-tune the distance between yourself and a target enemy."
        prep = 0
        execute = 4
        recoil = 0
        cooldown = 3
        fatigue_cost = 0
        target = user  # this will be changed during the combat loop when the user selects his target
        super().__init__(name="Tactical Positioning", description=description, xp_gain=0, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=(0, 100),
                         stage_announce=["",
                                         "",
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=target, user=user)
        self.distance = 0
        self.evaluate()

    def viable(self):
        return True

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        # self.stage_beat = [0,2,2,2]
        pass

    def prep(self, user):
        distance = ''
        while not functions.is_input_integer(distance):
            distance = input(
                "Enter the desired distance between yourself and your target (min {}, max {}): ".format(self.mvrange[0],
                                                                                                        self.mvrange[
                                                                                                            1]), )
            if functions.is_input_integer(distance):
                distance = int(
                    distance)  # forced typecasting is required because inputs are strings;
                # is_input_integer only tests if the entered string follows the integer pattern (numeral, no decimal)
                if distance > 100 or distance < 0:
                    cprint("You must enter a distance between {} and {}.".format(self.mvrange[0], self.mvrange[1]),
                           "red")
                    distance = ''
        self.distance = distance

    def execute(self, user):
        print("{} adjusts his position in relation to {}...".format(user.name, self.target.name))
        # modify the target position inputted by the player by some variance
        variance = (self.target.speed * random.uniform(0.5, 1.5)) - (self.user.speed * random.uniform(0.5, 1.5))
        if variance < 1:
            variance = 1
        variance = int(variance)
        targetposition = random.randint(self.distance - variance, self.distance + variance)
        if targetposition < self.mvrange[0]:
            targetposition = self.mvrange[0]
        if targetposition > self.mvrange[1]:
            targetposition = self.mvrange[1]
        # next, get the distance between the user and the target
        currentposition = int(user.combat_proximity[self.target])
        # now, evaluate the distance to move and execute
        distance = currentposition - targetposition
        if distance > 0:  # player will move closer to target
            print("{} got {} ft closer to {}!".format(user.name, distance, self.target.name))
            user.combat_proximity[self.target] -= distance
            user.combat_proximity[self.target] = int(user.combat_proximity[self.target])
            self.target.combat_proximity[user] = user.combat_proximity[self.target]
            user.combat_exp["Basic"] += 5
        elif distance < 0:  # player will move further away from target
            print("{} got {} ft further away from {}!".format(user.name, distance, self.target.name))
            user.combat_proximity[self.target] += distance
            user.combat_proximity[self.target] = int(user.combat_proximity[self.target])
            self.target.combat_proximity[user] = user.combat_proximity[self.target]
            user.combat_exp["Basic"] += 5
        else:
            print("{} was unable to get closer to {}!".format(user.name, self.target.name))


class ShootBow(Move):  # ranged attack with a bow, player only. Requires having arrows in inventory;
    # this is checked when available skills are evaluated in combat.py
    def __init__(self, player):
        description = "Fire an arrow at a target enemy. You must have arrows in your inventory to use. " \
                      "If you have multiple types of arrows, you may choose which type to fire."
        prep = 10
        execute = 1
        recoil = 1  # bows do not have significant recoil
        cooldown = 3
        fatigue_cost = 100 - (5 * player.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        mvrange = (6, 50)
        super().__init__(name="Shoot Bow", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=["Jean reaches into his quiver.",
                                         colored("Jean lets his arrow fly!", "green"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost, beats_left=prep,
                         target=None, user=player, verbose_targeting=True)
        self.arrow = items.WoodenArrow()  # modified later, based on player arrow type fired;
        # arrow type chosen at prep stage
        self.power = 0
        self.base_damage_type = items.get_base_damage_type(player.eq_weapon)
        self.accuracy = 1.0
        self.base_range = 20
        self.decay = 0.05
        self.evaluate()

    def calculate_hit_chance(self, enemy):  # estimate the hit chance for enemy and return as a string (ex "48%")
        hit_chance = 2
        range_min = self.mvrange[0]
        effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
        range_max = effective_range
        target_distance = self.user.combat_proximity[enemy]
        close_range_distraction = 0  # all enemies will be checked;
        # if any are closer than the weapon's min range, accuracy is halved
        for e, dist in self.user.combat_proximity.items():
            if e != self.user:
                close_range_distraction = 1
                break
        if range_min <= target_distance <= range_max:  # check if target is still in range
            hit_chance = (98 - enemy.finesse) + self.user.finesse
            hit_chance -= close_range_distraction * (hit_chance / 2)
            if target_distance > self.user.eq_weapon.range_base:
                accuracy_decay = (target_distance - self.user.eq_weapon.range_base) * self.decay
                hit_chance -= accuracy_decay
            if hit_chance < 2:  # Minimum value for hit chance
                hit_chance = 2
        for state in self.user.states:
            if state.name == "Hawkeye":
                hit_chance *= 1.4
        return hit_chance

    def viable(self):
        viability = False
        has_bow = False
        enemy_in_range = False
        has_arrows = False
        if self.user.eq_weapon.subtype == "Bow":
            has_bow = True

        range_min = self.mvrange[0]
        if hasattr(self.user.eq_weapon, "range_base"):
            effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
            range_max = effective_range
            for enemy, distance in self.user.combat_proximity.items():
                if range_min <= distance <= range_max:
                    enemy_in_range = True
                    break

        if hasattr(self.user, "inventory"):
            for item in self.user.inventory:
                if hasattr(item, "subtype"):
                    if item.subtype == "Arrow":
                        has_arrows = True
                        break

        if has_bow and enemy_in_range and has_arrows:
            viability = True
        return viability

    def prep(self, player):
        # first, check if there is more than one type of arrow. If so, build a menu, else skip to modifying effects
        arrowtypes = []
        for arrowtype in self.user.inventory:
            if arrowtype.subtype == "Arrow":
                if arrowtype.count > 0:  # in case the arrow stack hasn't had a chance to remove itself, check the count
                    arrowtypes.append(arrowtype)
        if len(arrowtypes) > 1:  # build our menu
            show_menu = True
            for arrow in arrowtypes:
                if arrow.name == player.preferences["arrow"]:
                    self.arrow = arrow
                    show_menu = False
            if show_menu:
                cprint("Select an arrow type...", "cyan")
                for i, v in enumerate(arrowtypes):
                    print(colored(str(i) + ": " + v.name, "cyan") + "(" + v.helptext + ")")
                arrow_selection = None
                while not arrow_selection:
                    arrow_selection = input(colored('Selection: ', "cyan"))
                    if functions.is_input_integer(arrow_selection):
                        arrow_selection = int(arrow_selection)
                        if arrow_selection < len(arrowtypes):
                            self.arrow = arrowtypes[arrow_selection]
                            break
                    cprint("Invalid selection! Please try again.", "red")
                    arrow_selection = None
        else:
            self.arrow = arrowtypes[0]
        print("Jean knocks a {} and takes aim!".format(self.arrow.name.lower()))
        self.base_range = player.eq_weapon.range_base * self.arrow.range_base_modifier
        self.decay = player.eq_weapon.range_decay * self.arrow.range_decay_modifier
        self.base_damage_type = items.get_base_damage_type(
            self.arrow)  # in case the arrow has a different base damage type than Piercing
        self.power = self.arrow.power
        if self.arrow.effects:
            for effect in self.arrow.effects:
                if effect.trigger == "prep":
                    effect.process()

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = 0
        prep = int(100 / ((self.user.speed * 0.7) + (self.user.strength * 0.3)))  # starting prep of 10
        if prep < 1:
            prep = 1
        execute = 1
        recoil = 1
        cooldown = 3 - int(self.user.speed / 20)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 100 - (5 * self.user.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        # effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
        # weapon_name = self.user.eq_weapon.name
        # self.stage_announce[1] = colored("Jean lets his " + weapon_name + " fly!", "green")
        # ^^^ TBD when arrow is selected
        self.power = power
        self.stage_beat = [prep, execute, recoil, cooldown]
        self.fatigue_cost = fatigue_cost
        # self.mvrange = (6, effective_range)
        self.base_damage_type = items.get_base_damage_type(self.arrow)
        # self.base_range = self.user.eq_weapon.range_base
        # self.decay = self.user.eq_weapon.range_decay

    def execute(self, player):
        glance = False  # switch for determining a glancing blow
        self.prep_colors()
        range_min = self.mvrange[0]
        effective_range = self.user.eq_weapon.range_base + (100 / self.user.eq_weapon.range_decay)
        range_max = effective_range
        target_distance = player.combat_proximity[self.target]
        # close_range_distraction = 0  # all enemies will be checked;
        # # if any are closer than the weapon's min range, accuracy is halved
        # for e, dist in self.user.combat_proximity.items():
        #     if e != self.user:
        #         if dist < range_min:
        #             close_range_distraction = 1
        #             break
        if range_min <= target_distance <= range_max:  # check if target is still in range
            hit_chance = self.calculate_hit_chance(self.target)
            print(self.stage_announce[1])
            if self.arrow.count > 1:
                self.arrow.count -= 1
            else:
                self.user.inventory.remove(self.arrow)

        else:
            cprint("Jean relaxes his bow as his target is no longer in range.", "green")
            return
        roll = random.randint(0, 100)
        arrow_recovery = self.arrow.sturdiness
        self.power += (self.user.finesse * self.user.eq_weapon.fin_mod)
        damage = (((self.power * self.target.resistance[
            self.base_damage_type]) - self.target.protection) * player.heat) * random.uniform(0.8, 1.2)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
            arrow_recovery *= 1.1
        damage = int(damage)
        player.combat_exp["Bow"] += 10
        arrow_location = "tile"
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                arrow_recovery *= 0.3
                self.parry()
            else:
                self.hit(damage, glance)
                arrow_location = "target"
                if self.arrow.effects:
                    for effect in self.arrow.effects:
                        if effect.trigger == "execute":
                            effect.process()
        else:
            arrow_recovery *= 1.8
            self.miss()
        self.user.fatigue -= self.fatigue_cost
        if arrow_recovery >= random.random():
            # arrow survived the shot; spawn one
            if arrow_location == "tile":
                self.user.current_room.spawn_item(self.arrow.__class__.__name__, hidden=1,
                                                  hfactor=random.randint(40, 80))


"""
NPC MOVES
"""


class NpcAttack(Move):  # basic attack function, NPCs only
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        self.power = 0
        if not npc.target:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="NPC_Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                                         colored("{} lashes out at {} with "
                                                 "extreme violence!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        range_min = self.mvrange[0]
        range_max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if range_min < distance < range_max:
                viability = True
                break

        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(0.8, 1.2))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 1
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 100 - (5 * self.user.endurance)
        if fatigue_cost <= 10:
            fatigue_cost = 10
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                               colored("{} lashes out at {} with "
                                       "extreme violence!".format(npc.name, self.target.name), "red"),
                               "{} recoils from the attack.".format(npc.name),
                               ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (95 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class NpcRest(Move):  # standard rest to restore fatigue for NPCs.
    def __init__(self, npc):
        description = "Rest for a moment to restore fatigue."
        prep = 0
        execute = 1
        recoil = 2
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Rest", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep, execute, recoil, cooldown],
                         stage_announce=["{} rests for a moment.".format(npc.name),
                                         colored("{} is resting.".format(npc.name), "white"),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=npc, user=npc)

    def execute(self, npc):
        print(self.stage_announce[1])
        recovery_amt = (self.user.maxfatigue * 0.25) * random.uniform(0.8, 1.2)
        recovery_amt = int(recovery_amt)
        if recovery_amt > self.user.maxfatigue - self.user.fatigue:
            recovery_amt = self.user.maxfatigue - self.user.fatigue
        self.user.fatigue += recovery_amt


class NpcIdle(Move):  # NPC does nothing for a few beats.
    def __init__(self, npc):
        description = "What?"
        prep = 0
        execute = 3
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        super().__init__(name="Idle", description=description, xp_gain=0, current_stage=0,
                         targeted=False,
                         stage_beat=[prep, execute, recoil, cooldown],
                         stage_announce=["",
                                         str(npc.name + npc.idle_message),
                                         "",
                                         ""], fatigue_cost=fatigue_cost,
                         beats_left=execute, target=npc, user=npc)

    def execute(self, npc):
        print(self.stage_announce[1])


class GorranClub(Move):  # Gorran's special club attack! Massive damage, long recoil
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 2
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        self.power = 0
        if npc.target is None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="NPC_Attack", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[
                             colored("{} grips his massive club in preparation to strike!".format(npc.name), "red"),
                             colored("{} swings his club mightily at {}!".format(npc.name, npc.target.name), "red"),
                             "{} recoils heavily from the attack.".format(npc.name),
                             ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        range_min = self.mvrange[0]
        range_max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if range_min < distance < range_max:
                viability = True
                break
        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(1.5, 3))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 2
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        recoil += 5
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        cooldown += 3
        fatigue_cost = 100 - (3 * self.user.endurance)
        if fatigue_cost <= 25:
            fatigue_cost = 25
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} grips his massive club in preparation to strike!".format(npc.name), "red"),
                               colored("{} swings his club mightily at {}!".format(npc.name, npc.target.name), "red"),
                               "{} recoils heavily from the attack.".format(npc.name),
                               ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (105 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class VenomClaw(Move):  # Poisonous attack
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        self.power = 0
        if npc.target is None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="VenomClaw", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                                         colored("{} slashes at {} with "
                                                 "its venomous claws!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        range_min = self.mvrange[0]
        range_max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if range_min < distance < range_max:
                viability = True
                break

        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(0.6, 1))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 1
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 120 - (5 * self.user.endurance)
        if fatigue_cost <= 20:
            fatigue_cost = 20
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} coils in preparation for an attack!".format(npc.name), "red"),
                               colored("{} slashes at {} with "
                                       "its venomous claws!".format(npc.name, npc.target.name), "red"),
                               "{} recoils from the attack.".format(npc.name),
                               ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (95 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
                status = states.Poisoned(self.target)
                functions.inflict(status, self.target, chance=0.3)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost


class SpiderBite(Move):  # Poisonous attack
    def __init__(self, npc):
        description = ""
        prep = 0
        execute = 1
        recoil = 0
        cooldown = 0
        fatigue_cost = 0
        self.power = 0
        if npc.target is None:
            npc.target = npc
        mvrange = npc.combat_range
        super().__init__(name="SpiderBite", description=description, xp_gain=1, current_stage=0,
                         stage_beat=[prep, execute, recoil, cooldown], targeted=True, mvrange=mvrange,
                         stage_announce=[colored("{} flashes its poisonous mandibles!".format(npc.name), "red"),
                                         colored("{} bites at {} with "
                                                 "its poisonous mandibles!".format(npc.name, npc.target.name), "red"),
                                         "{} recoils from the attack.".format(npc.name),
                                         ""],
                         fatigue_cost=fatigue_cost, beats_left=prep,
                         target=npc.target, user=npc)
        self.evaluate()

    def viable(self):
        viability = False
        range_min = self.mvrange[0]
        range_max = self.mvrange[1]
        for enemy, distance in self.user.combat_proximity.items():
            if range_min < distance < range_max:
                viability = True
                break

        return viability

    def evaluate(self):  # adjusts the move's attributes to match the current game state
        power = (self.user.damage * random.uniform(0.8, 1.2))
        prep = int(50 / self.user.speed)
        if prep < 1:
            prep = 1
        execute = 1
        recoil = int(50 / self.user.speed)
        if recoil < 0:
            recoil = 0
        cooldown = 5 - int(self.user.speed / 10)
        if cooldown < 0:
            cooldown = 0
        fatigue_cost = 120 - (5 * self.user.endurance)
        if fatigue_cost <= 20:
            fatigue_cost = 20
        self.power = power
        self.stage_beat[0] = prep
        self.stage_beat[1] = execute
        self.stage_beat[2] = recoil
        self.stage_beat[3] = cooldown
        self.fatigue_cost = fatigue_cost
        self.mvrange = self.user.combat_range

    def refresh_announcements(self, npc):
        self.stage_announce = [colored("{} flashes its poisonous mandibles!".format(npc.name), "red"),
                               colored("{} bites at {} with "
                                       "its poisonous mandibles!".format(npc.name, npc.target.name), "red"),
                               "{} recoils from the attack.".format(npc.name),
                               ""]

    def execute(self, npc):
        self.refresh_announcements(npc)
        print(self.stage_announce[1])
        self.prep_colors()
        glance = False
        if self.viable():
            hit_chance = (95 - self.target.finesse) + self.user.finesse
            if hit_chance <= 0:
                hit_chance = 1
        else:
            hit_chance = -1
        roll = random.randint(0, 100)
        damage = (self.power - self.target.protection)
        if damage <= 0:
            damage = 0
        if hit_chance >= roll and hit_chance - roll < 10:  # glancing blow
            damage /= 2
            glance = True
        damage = int(damage)
        if hit_chance >= roll:  # a hit!
            if functions.check_parry(self.target):
                self.parry()
            else:
                self.hit(damage, glance)
                status = states.Poisoned(self.target)
                functions.inflict(status, self.target, chance=0.15)
        else:
            self.miss()
        self.user.fatigue -= self.fatigue_cost
